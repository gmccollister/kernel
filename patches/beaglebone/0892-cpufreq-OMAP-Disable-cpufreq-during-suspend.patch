From 3002698666a8208756ca08ebf7bc025e6e6285bd Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Mon, 12 Mar 2012 23:35:47 +0530
Subject: [PATCH 0892/1092] cpufreq: OMAP: Disable cpufreq during suspend

On AM335x, we need to reconfigure the PLLs and voltage
during suspend. With regulator calls in the suspend code
errors were reported by the cpufreq driver in the resume
path. This is probably because cpufreq is suspended
very late in the overall suspend process.

For now, we make use of SUSPEND_PREPARE notification
to block any further OPP changes from the driver.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-omap2/pm33xx.c   |  1 +
 drivers/cpufreq/omap-cpufreq.c | 26 ++++++++++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index 1649b5f..ee56a0f 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -24,6 +24,7 @@
 #include <linux/sched.h>
 #include <linux/suspend.h>
 #include <linux/completion.h>
+#include <linux/regulator/consumer.h>
 
 #include <plat/prcm.h>
 #include <plat/mailbox.h>
diff --git a/drivers/cpufreq/omap-cpufreq.c b/drivers/cpufreq/omap-cpufreq.c
index 8332912..39d8d36 100644
--- a/drivers/cpufreq/omap-cpufreq.c
+++ b/drivers/cpufreq/omap-cpufreq.c
@@ -26,6 +26,7 @@
 #include <linux/cpu.h>
 #include <linux/module.h>
 #include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
 
 #include <asm/system.h>
 #include <asm/smp_plat.h>
@@ -60,6 +61,8 @@ static struct clk *mpu_clk;
 static char *mpu_clk_name;
 static struct device *mpu_dev;
 static struct regulator *mpu_reg;
+static DEFINE_MUTEX(omap_cpu_lock);
+static bool is_suspended;
 
 static int omap_verify_speed(struct cpufreq_policy *policy)
 {
@@ -89,6 +92,9 @@ static int omap_target(struct cpufreq_policy *policy,
 	struct opp *opp;
 	int volt_old = 0, volt_new = 0;
 
+	if (is_suspended)
+		return -EBUSY;
+
 	if (!freq_table) {
 		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
 				policy->cpu);
@@ -230,6 +236,24 @@ static inline void freq_table_free(void)
 		opp_free_cpufreq_table(mpu_dev, &freq_table);
 }
 
+static int omap_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+	mutex_lock(&omap_cpu_lock);
+	if (event == PM_SUSPEND_PREPARE) {
+		is_suspended = true;
+	} else if (event == PM_POST_SUSPEND) {
+		is_suspended = false;
+	}
+	mutex_unlock(&omap_cpu_lock);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block omap_cpu_pm_notifier = {
+	.notifier_call = omap_pm_notify,
+};
+
 static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 {
 	int result = 0;
@@ -295,6 +319,8 @@ static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 	/* FIXME: what's the actual transition time? */
 	policy->cpuinfo.transition_latency = 300 * 1000;
 
+	register_pm_notifier(&omap_cpu_pm_notifier);
+
 	return 0;
 
 fail_table:
-- 
1.7.11.2

