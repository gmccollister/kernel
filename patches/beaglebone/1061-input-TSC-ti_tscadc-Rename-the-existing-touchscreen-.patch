From c6e86a9b8c595faae87e6ce9e0f85adb25635134 Mon Sep 17 00:00:00 2001
From: "Patil, Rachna" <rachna@ti.com>
Date: Wed, 22 Aug 2012 12:17:35 +0530
Subject: [PATCH 1061/1092] input: TSC: ti_tscadc: Rename the existing
 touchscreen driver

Making way for addition of MFD driver.
The existing touchsreen driver is a MFD client.
For better readability we rename the file to
indicate its functionality as only touchscreen.

Signed-off-by: Patil, Rachna <rachna@ti.com>
---
 arch/arm/mach-omap2/board-am335xevm.c |   2 +-
 arch/arm/mach-omap2/devices.c         |   2 +-
 drivers/input/touchscreen/Kconfig     |   4 +-
 drivers/input/touchscreen/Makefile    |   2 +-
 drivers/input/touchscreen/ti_tsc.c    | 635 ++++++++++++++++++++++++++++++++++
 drivers/input/touchscreen/ti_tscadc.c | 635 ----------------------------------
 include/linux/input/ti_tsc.h          |  18 +
 include/linux/input/ti_tscadc.h       |  18 -
 8 files changed, 658 insertions(+), 658 deletions(-)
 create mode 100644 drivers/input/touchscreen/ti_tsc.c
 delete mode 100644 drivers/input/touchscreen/ti_tscadc.c
 create mode 100644 include/linux/input/ti_tsc.h
 delete mode 100644 include/linux/input/ti_tscadc.h

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index ed73f98..801d339 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -36,7 +36,7 @@
 #include <linux/mfd/tps65910.h>
 #include <linux/mfd/tps65217.h>
 #include <linux/pwm_backlight.h>
-#include <linux/input/ti_tscadc.h>
+#include <linux/input/ti_tsc.h>
 #include <linux/reboot.h>
 #include <linux/pwm/pwm.h>
 #include <linux/opp.h>
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 7c72dc0..a42791e 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -25,7 +25,7 @@
 #include <linux/can/platform/d_can.h>
 #include <linux/platform_data/uio_pruss.h>
 #include <linux/pwm/pwm.h>
-#include <linux/input/ti_tscadc.h>
+#include <linux/input/ti_tsc.h>
 
 #include <mach/hardware.h>
 #include <mach/irqs.h>
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index dab56e5..c7d3354 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -407,7 +407,7 @@ config TOUCHSCREEN_TOUCHWIN
 	  To compile this driver as a module, choose M here: the
 	  module will be called touchwin.
 
-config TOUCHSCREEN_TI_TSCADC
+config TOUCHSCREEN_TI_TSC
 	tristate "TI Touchscreen Interface"
 	help
 	  Say Y here if you have 4/5/8 wire touchscreen controller
@@ -416,7 +416,7 @@ config TOUCHSCREEN_TI_TSCADC
 	  If unsure, say N.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called ti_tscadc.
+	  module will be called ti_tsc.
 
 config TOUCHSCREEN_ATMEL_TSADCC
 	tristate "Atmel Touchscreen Interface"
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 124360b..24e8034 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -42,7 +42,7 @@ obj-$(CONFIG_TOUCHSCREEN_PENMOUNT)	+= penmount.o
 obj-$(CONFIG_TOUCHSCREEN_S3C2410)	+= s3c2410_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ST1232)	+= st1232.o
 obj-$(CONFIG_TOUCHSCREEN_STMPE)		+= stmpe-ts.o
-obj-$(CONFIG_TOUCHSCREEN_TI_TSCADC)	+= ti_tscadc.o
+obj-$(CONFIG_TOUCHSCREEN_TI_TSC)	+= ti_tsc.o
 obj-$(CONFIG_TOUCHSCREEN_TNETV107X)	+= tnetv107x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
diff --git a/drivers/input/touchscreen/ti_tsc.c b/drivers/input/touchscreen/ti_tsc.c
new file mode 100644
index 0000000..3b801be
--- /dev/null
+++ b/drivers/input/touchscreen/ti_tsc.c
@@ -0,0 +1,635 @@
+/*
+ * TI Touch Screen driver
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/input/ti_tsc.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+
+#define TSCADC_REG_RAWIRQSTATUS		0x024
+#define TSCADC_REG_IRQSTATUS		0x028
+#define TSCADC_REG_IRQENABLE		0x02C
+#define TSCADC_REG_IRQCLR		0x030
+#define TSCADC_REG_IRQWAKEUP		0x034
+#define TSCADC_REG_CTRL			0x040
+#define TSCADC_REG_ADCFSM		0x044
+#define TSCADC_REG_CLKDIV		0x04C
+#define TSCADC_REG_SE			0x054
+#define TSCADC_REG_IDLECONFIG		0x058
+#define TSCADC_REG_CHARGECONFIG		0x05C
+#define TSCADC_REG_CHARGEDELAY		0x060
+#define TSCADC_REG_STEPCONFIG(n)	(0x64 + ((n-1) * 8))
+#define TSCADC_REG_STEPDELAY(n)		(0x68 + ((n-1) * 8))
+#define TSCADC_REG_STEPCONFIG13		0x0C4
+#define TSCADC_REG_STEPDELAY13		0x0C8
+#define TSCADC_REG_STEPCONFIG14		0x0CC
+#define TSCADC_REG_STEPDELAY14		0x0D0
+#define TSCADC_REG_FIFO0CNT		0xE4
+#define TSCADC_REG_FIFO0THR		0xE8
+#define TSCADC_REG_FIFO1CNT		0xF0
+#define TSCADC_REG_FIFO1THR		0xF4
+#define TSCADC_REG_FIFO0		0x100
+#define TSCADC_REG_FIFO1		0x200
+
+/*	Register Bitfields	*/
+/* IRQ wakeup enable */
+#define TSCADC_IRQWKUP_ENB		BIT(0)
+
+/* Step Enable */
+#define TSCADC_STEPENB_MASK		(0x1FFFF << 0)
+#define TSCADC_STEPENB(val)		((val) << 0)
+#define TSCADC_STPENB_STEPENB		TSCADC_STEPENB(0x7FFF)
+
+/* IRQ enable */
+#define TSCADC_IRQENB_FIFO0THRES	BIT(2)
+#define TSCADC_IRQENB_FIFO1THRES	BIT(5)
+#define TSCADC_IRQENB_PENUP		BIT(9)
+#define TSCADC_IRQENB_HW_PEN		BIT(0)
+
+/* Step Configuration */
+#define TSCADC_STEPCONFIG_MODE_MASK	(3 << 0)
+#define TSCADC_STEPCONFIG_MODE(val)	((val) << 0)
+#define TSCADC_STEPCONFIG_MODE_HWSYNC	TSCADC_STEPCONFIG_MODE(2)
+#define TSCADC_STEPCONFIG_AVG_MASK	(7 << 2)
+#define TSCADC_STEPCONFIG_AVG(val)	((val) << 2)
+#define TSCADC_STEPCONFIG_AVG_16	TSCADC_STEPCONFIG_AVG(4)
+#define TSCADC_STEPCONFIG_XPP		BIT(5)
+#define TSCADC_STEPCONFIG_XNN		BIT(6)
+#define TSCADC_STEPCONFIG_YPP		BIT(7)
+#define TSCADC_STEPCONFIG_YNN		BIT(8)
+#define TSCADC_STEPCONFIG_XNP		BIT(9)
+#define TSCADC_STEPCONFIG_YPN		BIT(10)
+#define TSCADC_STEPCONFIG_INM_MASK	(0xF << 15)
+#define TSCADC_STEPCONFIG_INM(val)	((val) << 15)
+#define TSCADC_STEPCONFIG_INM_ADCREFM	TSCADC_STEPCONFIG_INM(8)
+#define TSCADC_STEPCONFIG_INP_MASK	(0xF << 19)
+#define TSCADC_STEPCONFIG_INP(val)	((val) << 19)
+#define TSCADC_STEPCONFIG_INP_AN2	TSCADC_STEPCONFIG_INP(2)
+#define TSCADC_STEPCONFIG_INP_AN3	TSCADC_STEPCONFIG_INP(3)
+#define TSCADC_STEPCONFIG_INP_AN4	TSCADC_STEPCONFIG_INP(4)
+#define TSCADC_STEPCONFIG_INP_ADCREFM	TSCADC_STEPCONFIG_INP(8)
+#define TSCADC_STEPCONFIG_FIFO1		BIT(26)
+
+/* Delay register */
+#define TSCADC_STEPDELAY_OPEN_MASK	(0x3FFFF << 0)
+#define TSCADC_STEPDELAY_OPEN(val)	((val) << 0)
+#define TSCADC_STEPCONFIG_OPENDLY	TSCADC_STEPDELAY_OPEN(0x098)
+#define TSCADC_STEPDELAY_SAMPLE_MASK	(0xFF << 24)
+#define TSCADC_STEPDELAY_SAMPLE(val)	((val) << 24)
+#define TSCADC_STEPCONFIG_SAMPLEDLY	TSCADC_STEPDELAY_SAMPLE(0)
+
+/* Charge Config */
+#define TSCADC_STEPCHARGE_RFP_MASK	(7 << 12)
+#define TSCADC_STEPCHARGE_RFP(val)	((val) << 12)
+#define TSCADC_STEPCHARGE_RFP_XPUL	TSCADC_STEPCHARGE_RFP(1)
+#define TSCADC_STEPCHARGE_INM_MASK	(0xF << 15)
+#define TSCADC_STEPCHARGE_INM(val)	((val) << 15)
+#define TSCADC_STEPCHARGE_INM_AN1	TSCADC_STEPCHARGE_INM(1)
+#define TSCADC_STEPCHARGE_INP_MASK	(0xF << 19)
+#define TSCADC_STEPCHARGE_INP(val)	((val) << 19)
+#define TSCADC_STEPCHARGE_INP_AN1	TSCADC_STEPCHARGE_INP(1)
+#define TSCADC_STEPCHARGE_RFM_MASK	(3 << 23)
+#define TSCADC_STEPCHARGE_RFM(val)	((val) << 23)
+#define TSCADC_STEPCHARGE_RFM_XNUR	TSCADC_STEPCHARGE_RFM(1)
+
+/* Charge delay */
+#define TSCADC_CHARGEDLY_OPEN_MASK	(0x3FFFF << 0)
+#define TSCADC_CHARGEDLY_OPEN(val)	((val) << 0)
+#define TSCADC_CHARGEDLY_OPENDLY	TSCADC_CHARGEDLY_OPEN(1)
+
+/* Control register */
+#define TSCADC_CNTRLREG_TSCSSENB	BIT(0)
+#define TSCADC_CNTRLREG_STEPID		BIT(1)
+#define TSCADC_CNTRLREG_STEPCONFIGWRT	BIT(2)
+#define TSCADC_CNTRLREG_POWERDOWN	BIT(4)
+#define TSCADC_CNTRLREG_AFE_CTRL_MASK	(3 << 5)
+#define TSCADC_CNTRLREG_AFE_CTRL(val)	((val) << 5)
+#define TSCADC_CNTRLREG_4WIRE		TSCADC_CNTRLREG_AFE_CTRL(1)
+#define TSCADC_CNTRLREG_5WIRE		TSCADC_CNTRLREG_AFE_CTRL(2)
+#define TSCADC_CNTRLREG_8WIRE		TSCADC_CNTRLREG_AFE_CTRL(3)
+#define TSCADC_CNTRLREG_TSCENB		BIT(7)
+
+#define ADC_CLK				3000000
+#define MAX_12BIT                       ((1 << 12) - 1)
+
+int pen = 1;
+unsigned int bckup_x = 0, bckup_y = 0;
+
+struct tscadc {
+	struct input_dev	*input;
+	int			wires;
+	int			x_plate_resistance;
+	int			irq;
+	void __iomem		*tsc_base;
+	unsigned int		ctrl;
+	int			steps_to_config;
+};
+
+static unsigned int tscadc_readl(struct tscadc *ts, unsigned int reg)
+{
+	return readl(ts->tsc_base + reg);
+}
+
+static void tscadc_writel(struct tscadc *tsc, unsigned int reg,
+					unsigned int val)
+{
+	writel(val, tsc->tsc_base + reg);
+}
+
+static void tsc_step_config(struct tscadc *ts_dev)
+{
+	unsigned int	stepconfigx = 0, stepconfigy = 0;
+	unsigned int	delay, chargeconfig = 0;
+	unsigned int	stepconfigz1 = 0, stepconfigz2 = 0;
+	int		i, total_steps;
+
+	/* Configure the Step registers */
+
+	delay = TSCADC_STEPCONFIG_SAMPLEDLY | TSCADC_STEPCONFIG_OPENDLY;
+
+	total_steps = 2 * ts_dev->steps_to_config;
+	stepconfigx = TSCADC_STEPCONFIG_MODE_HWSYNC |
+			TSCADC_STEPCONFIG_AVG_16 | TSCADC_STEPCONFIG_XPP;
+
+	switch (ts_dev->wires) {
+	case 4:
+		stepconfigx |= TSCADC_STEPCONFIG_INP_AN2 |
+				TSCADC_STEPCONFIG_XNN;
+		break;
+	case 5:
+		stepconfigx |= TSCADC_STEPCONFIG_YNN |
+				TSCADC_STEPCONFIG_INP_AN4 |
+				TSCADC_STEPCONFIG_XNN |
+				TSCADC_STEPCONFIG_YPP;
+		break;
+	case 8:
+		stepconfigx |= TSCADC_STEPCONFIG_INP_AN2 |
+				TSCADC_STEPCONFIG_XNN;
+		break;
+	}
+
+	for (i = 1; i <= ts_dev->steps_to_config; i++) {
+		tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(i), stepconfigx);
+		tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(i), delay);
+	}
+
+	stepconfigy = TSCADC_STEPCONFIG_MODE_HWSYNC |
+			TSCADC_STEPCONFIG_AVG_16 | TSCADC_STEPCONFIG_YNN |
+			TSCADC_STEPCONFIG_INM_ADCREFM | TSCADC_STEPCONFIG_FIFO1;
+	switch (ts_dev->wires) {
+	case 4:
+		stepconfigy |= TSCADC_STEPCONFIG_YPP;
+		break;
+	case 5:
+		stepconfigy |= TSCADC_STEPCONFIG_XPP |
+			TSCADC_STEPCONFIG_INP_AN4 | TSCADC_STEPCONFIG_XNP |
+			TSCADC_STEPCONFIG_YPN;
+		break;
+	case 8:
+		stepconfigy |= TSCADC_STEPCONFIG_YPP;
+		break;
+	}
+
+	for (i = (ts_dev->steps_to_config + 1); i <= total_steps; i++) {
+		tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(i), stepconfigy);
+		tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(i), delay);
+	}
+
+	chargeconfig = TSCADC_STEPCONFIG_XPP | TSCADC_STEPCONFIG_YNN |
+			TSCADC_STEPCHARGE_RFP_XPUL |
+			TSCADC_STEPCHARGE_RFM_XNUR |
+			TSCADC_STEPCHARGE_INM_AN1 | TSCADC_STEPCHARGE_INP_AN1;
+	tscadc_writel(ts_dev, TSCADC_REG_CHARGECONFIG, chargeconfig);
+	tscadc_writel(ts_dev, TSCADC_REG_CHARGEDELAY, TSCADC_CHARGEDLY_OPENDLY);
+
+	 /* Configure to calculate pressure */
+	stepconfigz1 = TSCADC_STEPCONFIG_MODE_HWSYNC |
+			TSCADC_STEPCONFIG_AVG_16 | TSCADC_STEPCONFIG_XNP |
+			TSCADC_STEPCONFIG_YPN | TSCADC_STEPCONFIG_INM_ADCREFM;
+	stepconfigz2 = stepconfigz1 | TSCADC_STEPCONFIG_INP_AN3 |
+				TSCADC_STEPCONFIG_FIFO1;
+	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(total_steps + 1),
+						stepconfigz1);
+	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(total_steps + 1), delay);
+	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(total_steps + 2),
+						stepconfigz2);
+	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(total_steps + 2), delay);
+
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
+}
+
+static void tsc_idle_config(struct tscadc *ts_config)
+{
+	/* Idle mode touch screen config */
+	unsigned int	 idleconfig;
+
+	idleconfig = TSCADC_STEPCONFIG_YNN | TSCADC_STEPCONFIG_INM_ADCREFM |
+			TSCADC_STEPCONFIG_INP_ADCREFM | TSCADC_STEPCONFIG_YPN;
+
+	tscadc_writel(ts_config, TSCADC_REG_IDLECONFIG, idleconfig);
+}
+
+static irqreturn_t tscadc_interrupt(int irq, void *dev)
+{
+	struct tscadc		*ts_dev = (struct tscadc *)dev;
+	struct input_dev	*input_dev = ts_dev->input;
+	unsigned int		status, irqclr = 0;
+	int			i;
+	int			fsm = 0, fifo0count = 0, fifo1count = 0;
+	unsigned int		readx1 = 0, ready1 = 0;
+	unsigned int		prev_val_x = ~0, prev_val_y = ~0;
+	unsigned int		prev_diff_x = ~0, prev_diff_y = ~0;
+	unsigned int		cur_diff_x = 0, cur_diff_y = 0;
+	unsigned int		val_x = 0, val_y = 0, diffx = 0, diffy = 0;
+	unsigned int		z1 = 0, z2 = 0, z = 0;
+
+	status = tscadc_readl(ts_dev, TSCADC_REG_IRQSTATUS);
+
+	if (status & TSCADC_IRQENB_FIFO0THRES) {
+		fifo0count = tscadc_readl(ts_dev, TSCADC_REG_FIFO0CNT);
+		fifo1count = tscadc_readl(ts_dev, TSCADC_REG_FIFO1CNT);
+		for (i = 0; i < (fifo0count-1); i++) {
+			readx1 = tscadc_readl(ts_dev, TSCADC_REG_FIFO0);
+			readx1 = readx1 & 0xfff;
+			if (readx1 > prev_val_x)
+				cur_diff_x = readx1 - prev_val_x;
+			else
+				cur_diff_x = prev_val_x - readx1;
+
+			if (cur_diff_x < prev_diff_x) {
+				prev_diff_x = cur_diff_x;
+				val_x = readx1;
+			}
+
+			prev_val_x = readx1;
+			ready1 = tscadc_readl(ts_dev, TSCADC_REG_FIFO1);
+				ready1 &= 0xfff;
+			if (ready1 > prev_val_y)
+				cur_diff_y = ready1 - prev_val_y;
+			else
+				cur_diff_y = prev_val_y - ready1;
+
+			if (cur_diff_y < prev_diff_y) {
+				prev_diff_y = cur_diff_y;
+				val_y = ready1;
+			}
+
+			prev_val_y = ready1;
+		}
+
+		if (val_x > bckup_x) {
+			diffx = val_x - bckup_x;
+			diffy = val_y - bckup_y;
+		} else {
+			diffx = bckup_x - val_x;
+			diffy = bckup_y - val_y;
+		}
+		bckup_x = val_x;
+		bckup_y = val_y;
+
+		z1 = ((tscadc_readl(ts_dev, TSCADC_REG_FIFO0)) & 0xfff);
+		z2 = ((tscadc_readl(ts_dev, TSCADC_REG_FIFO1)) & 0xfff);
+
+		if ((z1 != 0) && (z2 != 0)) {
+			/*
+			 * cal pressure using formula
+			 * Resistance(touch) = x plate resistance *
+			 * x postion/4096 * ((z2 / z1) - 1)
+			 */
+			z = z2 - z1;
+			z *= val_x;
+			z *= ts_dev->x_plate_resistance;
+			z /= z1;
+			z = (z + 2047) >> 12;
+
+			/*
+			 * Sample found inconsistent by debouncing
+			 * or pressure is beyond the maximum.
+			 * Don't report it to user space.
+			 */
+			if (pen == 0) {
+				if ((diffx < 15) && (diffy < 15)
+						&& (z <= MAX_12BIT)) {
+					input_report_abs(input_dev, ABS_X,
+							val_x);
+					input_report_abs(input_dev, ABS_Y,
+							val_y);
+					input_report_abs(input_dev, ABS_PRESSURE,
+							z);
+					input_report_key(input_dev, BTN_TOUCH,
+							1);
+					input_sync(input_dev);
+				}
+			}
+		}
+		irqclr |= TSCADC_IRQENB_FIFO0THRES;
+	}
+
+	udelay(315);
+
+	status = tscadc_readl(ts_dev, TSCADC_REG_RAWIRQSTATUS);
+	if (status & TSCADC_IRQENB_PENUP) {
+		/* Pen up event */
+		fsm = tscadc_readl(ts_dev, TSCADC_REG_ADCFSM);
+		if (fsm == 0x10) {
+			pen = 1;
+			bckup_x = 0;
+			bckup_y = 0;
+			input_report_key(input_dev, BTN_TOUCH, 0);
+			input_report_abs(input_dev, ABS_PRESSURE, 0);
+			input_sync(input_dev);
+		} else {
+			pen = 0;
+		}
+		irqclr |= TSCADC_IRQENB_PENUP;
+	}
+	irqclr |= TSCADC_IRQENB_HW_PEN;
+
+	tscadc_writel(ts_dev, TSCADC_REG_IRQSTATUS, irqclr);
+
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
+	return IRQ_HANDLED;
+}
+
+/*
+* The functions for inserting/removing driver as a module.
+*/
+
+static	int __devinit tscadc_probe(struct platform_device *pdev)
+{
+	struct tscadc			*ts_dev;
+	struct input_dev		*input_dev;
+	int				err;
+	int				clk_value;
+	int				clock_rate, irqenable, ctrl;
+	struct	tsc_data		*pdata = pdev->dev.platform_data;
+	struct resource			*res;
+	struct clk			*clk;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource defined.\n");
+		return -EINVAL;
+	}
+
+	/* Allocate memory for device */
+	ts_dev = kzalloc(sizeof(struct tscadc), GFP_KERNEL);
+	if (!ts_dev) {
+		dev_err(&pdev->dev, "failed to allocate memory.\n");
+		return -ENOMEM;
+	}
+
+	ts_dev->irq = platform_get_irq(pdev, 0);
+	if (ts_dev->irq < 0) {
+		dev_err(&pdev->dev, "no irq ID is specified.\n");
+		return -ENODEV;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		dev_err(&pdev->dev, "failed to allocate input device.\n");
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+	ts_dev->input = input_dev;
+
+	res =  request_mem_region(res->start, resource_size(res), pdev->name);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to reserve registers.\n");
+		err = -EBUSY;
+		goto err_free_mem;
+	}
+
+	ts_dev->tsc_base = ioremap(res->start, resource_size(res));
+	if (!ts_dev->tsc_base) {
+		dev_err(&pdev->dev, "failed to map registers.\n");
+		err = -ENOMEM;
+		goto err_release_mem;
+	}
+
+	err = request_irq(ts_dev->irq, tscadc_interrupt, IRQF_DISABLED,
+				pdev->dev.driver->name, ts_dev);
+	if (err) {
+		dev_err(&pdev->dev, "failed to allocate irq.\n");
+		goto err_unmap_regs;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+
+	clk = clk_get(&pdev->dev, "adc_tsc_fck");
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "failed to get TSC fck\n");
+		err = PTR_ERR(clk);
+		goto err_free_irq;
+	}
+	clock_rate = clk_get_rate(clk);
+	clk_put(clk);
+	clk_value = clock_rate / ADC_CLK;
+	if (clk_value < 7) {
+		dev_err(&pdev->dev, "clock input less than min clock requirement\n");
+		err = -EINVAL;
+		goto err_fail;
+	}
+	/* TSCADC_CLKDIV needs to be configured to the value minus 1 */
+	clk_value = clk_value - 1;
+	tscadc_writel(ts_dev, TSCADC_REG_CLKDIV, clk_value);
+
+	ts_dev->wires = pdata->wires;
+	ts_dev->x_plate_resistance = pdata->x_plate_resistance;
+	ts_dev->steps_to_config = pdata->steps_to_configure;
+
+	/* Set the control register bits */
+	ctrl = TSCADC_CNTRLREG_STEPCONFIGWRT |
+			TSCADC_CNTRLREG_TSCENB |
+			TSCADC_CNTRLREG_STEPID;
+	switch (ts_dev->wires) {
+	case 4:
+		ctrl |= TSCADC_CNTRLREG_4WIRE;
+		break;
+	case 5:
+		ctrl |= TSCADC_CNTRLREG_5WIRE;
+		break;
+	case 8:
+		ctrl |= TSCADC_CNTRLREG_8WIRE;
+		break;
+	}
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
+	ts_dev->ctrl = ctrl;
+
+	/* Set register bits for Idel Config Mode */
+	tsc_idle_config(ts_dev);
+
+	/* IRQ Enable */
+	irqenable = TSCADC_IRQENB_FIFO0THRES;
+	tscadc_writel(ts_dev, TSCADC_REG_IRQENABLE, irqenable);
+
+	tsc_step_config(ts_dev);
+
+	tscadc_writel(ts_dev, TSCADC_REG_FIFO0THR, ts_dev->steps_to_config);
+
+	ctrl |= TSCADC_CNTRLREG_TSCSSENB;
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
+
+	input_dev->name = "ti-tsc-adcc";
+	input_dev->dev.parent = &pdev->dev;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);
+
+	/* register to the input system */
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_fail;
+
+	device_init_wakeup(&pdev->dev, true);
+	platform_set_drvdata(pdev, ts_dev);
+	return 0;
+
+err_fail:
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+err_free_irq:
+	free_irq(ts_dev->irq, ts_dev);
+err_unmap_regs:
+	iounmap(ts_dev->tsc_base);
+err_release_mem:
+	release_mem_region(res->start, resource_size(res));
+	input_free_device(ts_dev->input);
+err_free_mem:
+	platform_set_drvdata(pdev, NULL);
+	kfree(ts_dev);
+	return err;
+}
+
+static int __devexit tscadc_remove(struct platform_device *pdev)
+{
+	struct tscadc		*ts_dev = platform_get_drvdata(pdev);
+	struct resource		*res;
+
+	tscadc_writel(ts_dev, TSCADC_REG_SE, 0x00);
+	free_irq(ts_dev->irq, ts_dev);
+
+	input_unregister_device(ts_dev->input);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	iounmap(ts_dev->tsc_base);
+	release_mem_region(res->start, resource_size(res));
+
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	kfree(ts_dev);
+
+	device_init_wakeup(&pdev->dev, 0);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static int tscadc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct tscadc *ts_dev = platform_get_drvdata(pdev);
+	unsigned int idle;
+
+	if (device_may_wakeup(&pdev->dev)) {
+		idle = tscadc_readl(ts_dev, TSCADC_REG_IRQENABLE);
+		tscadc_writel(ts_dev, TSCADC_REG_IRQENABLE,
+				(idle | TSCADC_IRQENB_HW_PEN));
+		tscadc_writel(ts_dev, TSCADC_REG_SE, 0x00);
+		tscadc_writel(ts_dev, TSCADC_REG_IRQWAKEUP, TSCADC_IRQWKUP_ENB);
+	} else {
+	/* module disable */
+	idle = tscadc_readl(ts_dev, TSCADC_REG_CTRL);
+	idle &= ~(TSCADC_CNTRLREG_TSCSSENB);
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL, (idle |
+				TSCADC_CNTRLREG_POWERDOWN));
+	}
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	return 0;
+
+}
+
+static int tscadc_resume(struct platform_device *pdev)
+{
+	struct tscadc *ts_dev = platform_get_drvdata(pdev);
+	unsigned int restore;
+
+	pm_runtime_get_sync(&pdev->dev);
+
+	if (device_may_wakeup(&pdev->dev)) {
+		restore = tscadc_readl(ts_dev, TSCADC_REG_IRQWAKEUP);
+		restore &= ~(TSCADC_IRQWKUP_ENB);
+		tscadc_writel(ts_dev, TSCADC_REG_IRQWAKEUP, restore);
+		tscadc_writel(ts_dev, TSCADC_REG_IRQCLR, TSCADC_IRQENB_HW_PEN);
+	}
+
+	/* context restore */
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ts_dev->ctrl);
+	/* Make sure ADC is powered up */
+	restore = tscadc_readl(ts_dev, TSCADC_REG_CTRL);
+	restore &= ~(TSCADC_CNTRLREG_POWERDOWN);
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL, restore);
+	tsc_idle_config(ts_dev);
+	tsc_step_config(ts_dev);
+	tscadc_writel(ts_dev, TSCADC_REG_FIFO0THR, ts_dev->steps_to_config);
+	restore = tscadc_readl(ts_dev, TSCADC_REG_CTRL);
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL,
+			(restore | TSCADC_CNTRLREG_TSCSSENB));
+
+	return 0;
+}
+
+static struct platform_driver ti_tsc_driver = {
+	.probe	  = tscadc_probe,
+	.remove	 = __devexit_p(tscadc_remove),
+	.driver	 = {
+		.name   = "tsc",
+		.owner  = THIS_MODULE,
+	},
+	.suspend = tscadc_suspend,
+	.resume  = tscadc_resume,
+};
+
+static int __init ti_tsc_init(void)
+{
+	return platform_driver_register(&ti_tsc_driver);
+}
+module_init(ti_tsc_init);
+
+static void __exit ti_tsc_exit(void)
+{
+	platform_driver_unregister(&ti_tsc_driver);
+}
+module_exit(ti_tsc_exit);
+
+MODULE_DESCRIPTION("TI touchscreen controller driver");
+MODULE_AUTHOR("Rachna Patil <rachna@ti.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/ti_tscadc.c b/drivers/input/touchscreen/ti_tscadc.c
deleted file mode 100644
index 55be46a..0000000
--- a/drivers/input/touchscreen/ti_tscadc.c
+++ /dev/null
@@ -1,635 +0,0 @@
-/*
- * TI Touch Screen driver
- *
- * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/err.h>
-#include <linux/module.h>
-#include <linux/input.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/clk.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/input/ti_tscadc.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-
-#define TSCADC_REG_RAWIRQSTATUS		0x024
-#define TSCADC_REG_IRQSTATUS		0x028
-#define TSCADC_REG_IRQENABLE		0x02C
-#define TSCADC_REG_IRQCLR		0x030
-#define TSCADC_REG_IRQWAKEUP		0x034
-#define TSCADC_REG_CTRL			0x040
-#define TSCADC_REG_ADCFSM		0x044
-#define TSCADC_REG_CLKDIV		0x04C
-#define TSCADC_REG_SE			0x054
-#define TSCADC_REG_IDLECONFIG		0x058
-#define TSCADC_REG_CHARGECONFIG		0x05C
-#define TSCADC_REG_CHARGEDELAY		0x060
-#define TSCADC_REG_STEPCONFIG(n)	(0x64 + ((n-1) * 8))
-#define TSCADC_REG_STEPDELAY(n)		(0x68 + ((n-1) * 8))
-#define TSCADC_REG_STEPCONFIG13		0x0C4
-#define TSCADC_REG_STEPDELAY13		0x0C8
-#define TSCADC_REG_STEPCONFIG14		0x0CC
-#define TSCADC_REG_STEPDELAY14		0x0D0
-#define TSCADC_REG_FIFO0CNT		0xE4
-#define TSCADC_REG_FIFO0THR		0xE8
-#define TSCADC_REG_FIFO1CNT		0xF0
-#define TSCADC_REG_FIFO1THR		0xF4
-#define TSCADC_REG_FIFO0		0x100
-#define TSCADC_REG_FIFO1		0x200
-
-/*	Register Bitfields	*/
-/* IRQ wakeup enable */
-#define TSCADC_IRQWKUP_ENB		BIT(0)
-
-/* Step Enable */
-#define TSCADC_STEPENB_MASK		(0x1FFFF << 0)
-#define TSCADC_STEPENB(val)		((val) << 0)
-#define TSCADC_STPENB_STEPENB		TSCADC_STEPENB(0x7FFF)
-
-/* IRQ enable */
-#define TSCADC_IRQENB_FIFO0THRES	BIT(2)
-#define TSCADC_IRQENB_FIFO1THRES	BIT(5)
-#define TSCADC_IRQENB_PENUP		BIT(9)
-#define TSCADC_IRQENB_HW_PEN		BIT(0)
-
-/* Step Configuration */
-#define TSCADC_STEPCONFIG_MODE_MASK	(3 << 0)
-#define TSCADC_STEPCONFIG_MODE(val)	((val) << 0)
-#define TSCADC_STEPCONFIG_MODE_HWSYNC	TSCADC_STEPCONFIG_MODE(2)
-#define TSCADC_STEPCONFIG_AVG_MASK	(7 << 2)
-#define TSCADC_STEPCONFIG_AVG(val)	((val) << 2)
-#define TSCADC_STEPCONFIG_AVG_16	TSCADC_STEPCONFIG_AVG(4)
-#define TSCADC_STEPCONFIG_XPP		BIT(5)
-#define TSCADC_STEPCONFIG_XNN		BIT(6)
-#define TSCADC_STEPCONFIG_YPP		BIT(7)
-#define TSCADC_STEPCONFIG_YNN		BIT(8)
-#define TSCADC_STEPCONFIG_XNP		BIT(9)
-#define TSCADC_STEPCONFIG_YPN		BIT(10)
-#define TSCADC_STEPCONFIG_INM_MASK	(0xF << 15)
-#define TSCADC_STEPCONFIG_INM(val)	((val) << 15)
-#define TSCADC_STEPCONFIG_INM_ADCREFM	TSCADC_STEPCONFIG_INM(8)
-#define TSCADC_STEPCONFIG_INP_MASK	(0xF << 19)
-#define TSCADC_STEPCONFIG_INP(val)	((val) << 19)
-#define TSCADC_STEPCONFIG_INP_AN2	TSCADC_STEPCONFIG_INP(2)
-#define TSCADC_STEPCONFIG_INP_AN3	TSCADC_STEPCONFIG_INP(3)
-#define TSCADC_STEPCONFIG_INP_AN4	TSCADC_STEPCONFIG_INP(4)
-#define TSCADC_STEPCONFIG_INP_ADCREFM	TSCADC_STEPCONFIG_INP(8)
-#define TSCADC_STEPCONFIG_FIFO1		BIT(26)
-
-/* Delay register */
-#define TSCADC_STEPDELAY_OPEN_MASK	(0x3FFFF << 0)
-#define TSCADC_STEPDELAY_OPEN(val)	((val) << 0)
-#define TSCADC_STEPCONFIG_OPENDLY	TSCADC_STEPDELAY_OPEN(0x098)
-#define TSCADC_STEPDELAY_SAMPLE_MASK	(0xFF << 24)
-#define TSCADC_STEPDELAY_SAMPLE(val)	((val) << 24)
-#define TSCADC_STEPCONFIG_SAMPLEDLY	TSCADC_STEPDELAY_SAMPLE(0)
-
-/* Charge Config */
-#define TSCADC_STEPCHARGE_RFP_MASK	(7 << 12)
-#define TSCADC_STEPCHARGE_RFP(val)	((val) << 12)
-#define TSCADC_STEPCHARGE_RFP_XPUL	TSCADC_STEPCHARGE_RFP(1)
-#define TSCADC_STEPCHARGE_INM_MASK	(0xF << 15)
-#define TSCADC_STEPCHARGE_INM(val)	((val) << 15)
-#define TSCADC_STEPCHARGE_INM_AN1	TSCADC_STEPCHARGE_INM(1)
-#define TSCADC_STEPCHARGE_INP_MASK	(0xF << 19)
-#define TSCADC_STEPCHARGE_INP(val)	((val) << 19)
-#define TSCADC_STEPCHARGE_INP_AN1	TSCADC_STEPCHARGE_INP(1)
-#define TSCADC_STEPCHARGE_RFM_MASK	(3 << 23)
-#define TSCADC_STEPCHARGE_RFM(val)	((val) << 23)
-#define TSCADC_STEPCHARGE_RFM_XNUR	TSCADC_STEPCHARGE_RFM(1)
-
-/* Charge delay */
-#define TSCADC_CHARGEDLY_OPEN_MASK	(0x3FFFF << 0)
-#define TSCADC_CHARGEDLY_OPEN(val)	((val) << 0)
-#define TSCADC_CHARGEDLY_OPENDLY	TSCADC_CHARGEDLY_OPEN(1)
-
-/* Control register */
-#define TSCADC_CNTRLREG_TSCSSENB	BIT(0)
-#define TSCADC_CNTRLREG_STEPID		BIT(1)
-#define TSCADC_CNTRLREG_STEPCONFIGWRT	BIT(2)
-#define TSCADC_CNTRLREG_POWERDOWN	BIT(4)
-#define TSCADC_CNTRLREG_AFE_CTRL_MASK	(3 << 5)
-#define TSCADC_CNTRLREG_AFE_CTRL(val)	((val) << 5)
-#define TSCADC_CNTRLREG_4WIRE		TSCADC_CNTRLREG_AFE_CTRL(1)
-#define TSCADC_CNTRLREG_5WIRE		TSCADC_CNTRLREG_AFE_CTRL(2)
-#define TSCADC_CNTRLREG_8WIRE		TSCADC_CNTRLREG_AFE_CTRL(3)
-#define TSCADC_CNTRLREG_TSCENB		BIT(7)
-
-#define ADC_CLK				3000000
-#define MAX_12BIT                       ((1 << 12) - 1)
-
-int pen = 1;
-unsigned int bckup_x = 0, bckup_y = 0;
-
-struct tscadc {
-	struct input_dev	*input;
-	int			wires;
-	int			x_plate_resistance;
-	int			irq;
-	void __iomem		*tsc_base;
-	unsigned int		ctrl;
-	int			steps_to_config;
-};
-
-static unsigned int tscadc_readl(struct tscadc *ts, unsigned int reg)
-{
-	return readl(ts->tsc_base + reg);
-}
-
-static void tscadc_writel(struct tscadc *tsc, unsigned int reg,
-					unsigned int val)
-{
-	writel(val, tsc->tsc_base + reg);
-}
-
-static void tsc_step_config(struct tscadc *ts_dev)
-{
-	unsigned int	stepconfigx = 0, stepconfigy = 0;
-	unsigned int	delay, chargeconfig = 0;
-	unsigned int	stepconfigz1 = 0, stepconfigz2 = 0;
-	int		i, total_steps;
-
-	/* Configure the Step registers */
-
-	delay = TSCADC_STEPCONFIG_SAMPLEDLY | TSCADC_STEPCONFIG_OPENDLY;
-
-	total_steps = 2 * ts_dev->steps_to_config;
-	stepconfigx = TSCADC_STEPCONFIG_MODE_HWSYNC |
-			TSCADC_STEPCONFIG_AVG_16 | TSCADC_STEPCONFIG_XPP;
-
-	switch (ts_dev->wires) {
-	case 4:
-		stepconfigx |= TSCADC_STEPCONFIG_INP_AN2 |
-				TSCADC_STEPCONFIG_XNN;
-		break;
-	case 5:
-		stepconfigx |= TSCADC_STEPCONFIG_YNN |
-				TSCADC_STEPCONFIG_INP_AN4 |
-				TSCADC_STEPCONFIG_XNN |
-				TSCADC_STEPCONFIG_YPP;
-		break;
-	case 8:
-		stepconfigx |= TSCADC_STEPCONFIG_INP_AN2 |
-				TSCADC_STEPCONFIG_XNN;
-		break;
-	}
-
-	for (i = 1; i <= ts_dev->steps_to_config; i++) {
-		tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(i), stepconfigx);
-		tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(i), delay);
-	}
-
-	stepconfigy = TSCADC_STEPCONFIG_MODE_HWSYNC |
-			TSCADC_STEPCONFIG_AVG_16 | TSCADC_STEPCONFIG_YNN |
-			TSCADC_STEPCONFIG_INM_ADCREFM | TSCADC_STEPCONFIG_FIFO1;
-	switch (ts_dev->wires) {
-	case 4:
-		stepconfigy |= TSCADC_STEPCONFIG_YPP;
-		break;
-	case 5:
-		stepconfigy |= TSCADC_STEPCONFIG_XPP |
-			TSCADC_STEPCONFIG_INP_AN4 | TSCADC_STEPCONFIG_XNP |
-			TSCADC_STEPCONFIG_YPN;
-		break;
-	case 8:
-		stepconfigy |= TSCADC_STEPCONFIG_YPP;
-		break;
-	}
-
-	for (i = (ts_dev->steps_to_config + 1); i <= total_steps; i++) {
-		tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(i), stepconfigy);
-		tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(i), delay);
-	}
-
-	chargeconfig = TSCADC_STEPCONFIG_XPP | TSCADC_STEPCONFIG_YNN |
-			TSCADC_STEPCHARGE_RFP_XPUL |
-			TSCADC_STEPCHARGE_RFM_XNUR |
-			TSCADC_STEPCHARGE_INM_AN1 | TSCADC_STEPCHARGE_INP_AN1;
-	tscadc_writel(ts_dev, TSCADC_REG_CHARGECONFIG, chargeconfig);
-	tscadc_writel(ts_dev, TSCADC_REG_CHARGEDELAY, TSCADC_CHARGEDLY_OPENDLY);
-
-	 /* Configure to calculate pressure */
-	stepconfigz1 = TSCADC_STEPCONFIG_MODE_HWSYNC |
-			TSCADC_STEPCONFIG_AVG_16 | TSCADC_STEPCONFIG_XNP |
-			TSCADC_STEPCONFIG_YPN | TSCADC_STEPCONFIG_INM_ADCREFM;
-	stepconfigz2 = stepconfigz1 | TSCADC_STEPCONFIG_INP_AN3 |
-				TSCADC_STEPCONFIG_FIFO1;
-	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(total_steps + 1),
-						stepconfigz1);
-	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(total_steps + 1), delay);
-	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(total_steps + 2),
-						stepconfigz2);
-	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(total_steps + 2), delay);
-
-	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
-}
-
-static void tsc_idle_config(struct tscadc *ts_config)
-{
-	/* Idle mode touch screen config */
-	unsigned int	 idleconfig;
-
-	idleconfig = TSCADC_STEPCONFIG_YNN | TSCADC_STEPCONFIG_INM_ADCREFM |
-			TSCADC_STEPCONFIG_INP_ADCREFM | TSCADC_STEPCONFIG_YPN;
-
-	tscadc_writel(ts_config, TSCADC_REG_IDLECONFIG, idleconfig);
-}
-
-static irqreturn_t tscadc_interrupt(int irq, void *dev)
-{
-	struct tscadc		*ts_dev = (struct tscadc *)dev;
-	struct input_dev	*input_dev = ts_dev->input;
-	unsigned int		status, irqclr = 0;
-	int			i;
-	int			fsm = 0, fifo0count = 0, fifo1count = 0;
-	unsigned int		readx1 = 0, ready1 = 0;
-	unsigned int		prev_val_x = ~0, prev_val_y = ~0;
-	unsigned int		prev_diff_x = ~0, prev_diff_y = ~0;
-	unsigned int		cur_diff_x = 0, cur_diff_y = 0;
-	unsigned int		val_x = 0, val_y = 0, diffx = 0, diffy = 0;
-	unsigned int		z1 = 0, z2 = 0, z = 0;
-
-	status = tscadc_readl(ts_dev, TSCADC_REG_IRQSTATUS);
-
-	if (status & TSCADC_IRQENB_FIFO0THRES) {
-		fifo0count = tscadc_readl(ts_dev, TSCADC_REG_FIFO0CNT);
-		fifo1count = tscadc_readl(ts_dev, TSCADC_REG_FIFO1CNT);
-		for (i = 0; i < (fifo0count-1); i++) {
-			readx1 = tscadc_readl(ts_dev, TSCADC_REG_FIFO0);
-			readx1 = readx1 & 0xfff;
-			if (readx1 > prev_val_x)
-				cur_diff_x = readx1 - prev_val_x;
-			else
-				cur_diff_x = prev_val_x - readx1;
-
-			if (cur_diff_x < prev_diff_x) {
-				prev_diff_x = cur_diff_x;
-				val_x = readx1;
-			}
-
-			prev_val_x = readx1;
-			ready1 = tscadc_readl(ts_dev, TSCADC_REG_FIFO1);
-				ready1 &= 0xfff;
-			if (ready1 > prev_val_y)
-				cur_diff_y = ready1 - prev_val_y;
-			else
-				cur_diff_y = prev_val_y - ready1;
-
-			if (cur_diff_y < prev_diff_y) {
-				prev_diff_y = cur_diff_y;
-				val_y = ready1;
-			}
-
-			prev_val_y = ready1;
-		}
-
-		if (val_x > bckup_x) {
-			diffx = val_x - bckup_x;
-			diffy = val_y - bckup_y;
-		} else {
-			diffx = bckup_x - val_x;
-			diffy = bckup_y - val_y;
-		}
-		bckup_x = val_x;
-		bckup_y = val_y;
-
-		z1 = ((tscadc_readl(ts_dev, TSCADC_REG_FIFO0)) & 0xfff);
-		z2 = ((tscadc_readl(ts_dev, TSCADC_REG_FIFO1)) & 0xfff);
-
-		if ((z1 != 0) && (z2 != 0)) {
-			/*
-			 * cal pressure using formula
-			 * Resistance(touch) = x plate resistance *
-			 * x postion/4096 * ((z2 / z1) - 1)
-			 */
-			z = z2 - z1;
-			z *= val_x;
-			z *= ts_dev->x_plate_resistance;
-			z /= z1;
-			z = (z + 2047) >> 12;
-
-			/*
-			 * Sample found inconsistent by debouncing
-			 * or pressure is beyond the maximum.
-			 * Don't report it to user space.
-			 */
-			if (pen == 0) {
-				if ((diffx < 15) && (diffy < 15)
-						&& (z <= MAX_12BIT)) {
-					input_report_abs(input_dev, ABS_X,
-							val_x);
-					input_report_abs(input_dev, ABS_Y,
-							val_y);
-					input_report_abs(input_dev, ABS_PRESSURE,
-							z);
-					input_report_key(input_dev, BTN_TOUCH,
-							1);
-					input_sync(input_dev);
-				}
-			}
-		}
-		irqclr |= TSCADC_IRQENB_FIFO0THRES;
-	}
-
-	udelay(315);
-
-	status = tscadc_readl(ts_dev, TSCADC_REG_RAWIRQSTATUS);
-	if (status & TSCADC_IRQENB_PENUP) {
-		/* Pen up event */
-		fsm = tscadc_readl(ts_dev, TSCADC_REG_ADCFSM);
-		if (fsm == 0x10) {
-			pen = 1;
-			bckup_x = 0;
-			bckup_y = 0;
-			input_report_key(input_dev, BTN_TOUCH, 0);
-			input_report_abs(input_dev, ABS_PRESSURE, 0);
-			input_sync(input_dev);
-		} else {
-			pen = 0;
-		}
-		irqclr |= TSCADC_IRQENB_PENUP;
-	}
-	irqclr |= TSCADC_IRQENB_HW_PEN;
-
-	tscadc_writel(ts_dev, TSCADC_REG_IRQSTATUS, irqclr);
-
-	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
-	return IRQ_HANDLED;
-}
-
-/*
-* The functions for inserting/removing driver as a module.
-*/
-
-static	int __devinit tscadc_probe(struct platform_device *pdev)
-{
-	struct tscadc			*ts_dev;
-	struct input_dev		*input_dev;
-	int				err;
-	int				clk_value;
-	int				clock_rate, irqenable, ctrl;
-	struct	tsc_data		*pdata = pdev->dev.platform_data;
-	struct resource			*res;
-	struct clk			*clk;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "no memory resource defined.\n");
-		return -EINVAL;
-	}
-
-	/* Allocate memory for device */
-	ts_dev = kzalloc(sizeof(struct tscadc), GFP_KERNEL);
-	if (!ts_dev) {
-		dev_err(&pdev->dev, "failed to allocate memory.\n");
-		return -ENOMEM;
-	}
-
-	ts_dev->irq = platform_get_irq(pdev, 0);
-	if (ts_dev->irq < 0) {
-		dev_err(&pdev->dev, "no irq ID is specified.\n");
-		return -ENODEV;
-	}
-
-	input_dev = input_allocate_device();
-	if (!input_dev) {
-		dev_err(&pdev->dev, "failed to allocate input device.\n");
-		err = -ENOMEM;
-		goto err_free_mem;
-	}
-	ts_dev->input = input_dev;
-
-	res =  request_mem_region(res->start, resource_size(res), pdev->name);
-	if (!res) {
-		dev_err(&pdev->dev, "failed to reserve registers.\n");
-		err = -EBUSY;
-		goto err_free_mem;
-	}
-
-	ts_dev->tsc_base = ioremap(res->start, resource_size(res));
-	if (!ts_dev->tsc_base) {
-		dev_err(&pdev->dev, "failed to map registers.\n");
-		err = -ENOMEM;
-		goto err_release_mem;
-	}
-
-	err = request_irq(ts_dev->irq, tscadc_interrupt, IRQF_DISABLED,
-				pdev->dev.driver->name, ts_dev);
-	if (err) {
-		dev_err(&pdev->dev, "failed to allocate irq.\n");
-		goto err_unmap_regs;
-	}
-
-	pm_runtime_enable(&pdev->dev);
-	pm_runtime_get_sync(&pdev->dev);
-
-	clk = clk_get(&pdev->dev, "adc_tsc_fck");
-	if (IS_ERR(clk)) {
-		dev_err(&pdev->dev, "failed to get TSC fck\n");
-		err = PTR_ERR(clk);
-		goto err_free_irq;
-	}
-	clock_rate = clk_get_rate(clk);
-	clk_put(clk);
-	clk_value = clock_rate / ADC_CLK;
-	if (clk_value < 7) {
-		dev_err(&pdev->dev, "clock input less than min clock requirement\n");
-		err = -EINVAL;
-		goto err_fail;
-	}
-	/* TSCADC_CLKDIV needs to be configured to the value minus 1 */
-	clk_value = clk_value - 1;
-	tscadc_writel(ts_dev, TSCADC_REG_CLKDIV, clk_value);
-
-	ts_dev->wires = pdata->wires;
-	ts_dev->x_plate_resistance = pdata->x_plate_resistance;
-	ts_dev->steps_to_config = pdata->steps_to_configure;
-
-	/* Set the control register bits */
-	ctrl = TSCADC_CNTRLREG_STEPCONFIGWRT |
-			TSCADC_CNTRLREG_TSCENB |
-			TSCADC_CNTRLREG_STEPID;
-	switch (ts_dev->wires) {
-	case 4:
-		ctrl |= TSCADC_CNTRLREG_4WIRE;
-		break;
-	case 5:
-		ctrl |= TSCADC_CNTRLREG_5WIRE;
-		break;
-	case 8:
-		ctrl |= TSCADC_CNTRLREG_8WIRE;
-		break;
-	}
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
-	ts_dev->ctrl = ctrl;
-
-	/* Set register bits for Idel Config Mode */
-	tsc_idle_config(ts_dev);
-
-	/* IRQ Enable */
-	irqenable = TSCADC_IRQENB_FIFO0THRES;
-	tscadc_writel(ts_dev, TSCADC_REG_IRQENABLE, irqenable);
-
-	tsc_step_config(ts_dev);
-
-	tscadc_writel(ts_dev, TSCADC_REG_FIFO0THR, ts_dev->steps_to_config);
-
-	ctrl |= TSCADC_CNTRLREG_TSCSSENB;
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
-
-	input_dev->name = "ti-tsc-adcc";
-	input_dev->dev.parent = &pdev->dev;
-
-	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-
-	input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);
-	input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);
-	input_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);
-
-	/* register to the input system */
-	err = input_register_device(input_dev);
-	if (err)
-		goto err_fail;
-
-	device_init_wakeup(&pdev->dev, true);
-	platform_set_drvdata(pdev, ts_dev);
-	return 0;
-
-err_fail:
-	pm_runtime_put_sync(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
-err_free_irq:
-	free_irq(ts_dev->irq, ts_dev);
-err_unmap_regs:
-	iounmap(ts_dev->tsc_base);
-err_release_mem:
-	release_mem_region(res->start, resource_size(res));
-	input_free_device(ts_dev->input);
-err_free_mem:
-	platform_set_drvdata(pdev, NULL);
-	kfree(ts_dev);
-	return err;
-}
-
-static int __devexit tscadc_remove(struct platform_device *pdev)
-{
-	struct tscadc		*ts_dev = platform_get_drvdata(pdev);
-	struct resource		*res;
-
-	tscadc_writel(ts_dev, TSCADC_REG_SE, 0x00);
-	free_irq(ts_dev->irq, ts_dev);
-
-	input_unregister_device(ts_dev->input);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	iounmap(ts_dev->tsc_base);
-	release_mem_region(res->start, resource_size(res));
-
-	pm_runtime_put_sync(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
-
-	kfree(ts_dev);
-
-	device_init_wakeup(&pdev->dev, 0);
-	platform_set_drvdata(pdev, NULL);
-	return 0;
-}
-
-static int tscadc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct tscadc *ts_dev = platform_get_drvdata(pdev);
-	unsigned int idle;
-
-	if (device_may_wakeup(&pdev->dev)) {
-		idle = tscadc_readl(ts_dev, TSCADC_REG_IRQENABLE);
-		tscadc_writel(ts_dev, TSCADC_REG_IRQENABLE,
-				(idle | TSCADC_IRQENB_HW_PEN));
-		tscadc_writel(ts_dev, TSCADC_REG_SE, 0x00);
-		tscadc_writel(ts_dev, TSCADC_REG_IRQWAKEUP, TSCADC_IRQWKUP_ENB);
-	} else {
-	/* module disable */
-	idle = tscadc_readl(ts_dev, TSCADC_REG_CTRL);
-	idle &= ~(TSCADC_CNTRLREG_TSCSSENB);
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL, (idle |
-				TSCADC_CNTRLREG_POWERDOWN));
-	}
-
-	pm_runtime_put_sync(&pdev->dev);
-
-	return 0;
-
-}
-
-static int tscadc_resume(struct platform_device *pdev)
-{
-	struct tscadc *ts_dev = platform_get_drvdata(pdev);
-	unsigned int restore;
-
-	pm_runtime_get_sync(&pdev->dev);
-
-	if (device_may_wakeup(&pdev->dev)) {
-		restore = tscadc_readl(ts_dev, TSCADC_REG_IRQWAKEUP);
-		restore &= ~(TSCADC_IRQWKUP_ENB);
-		tscadc_writel(ts_dev, TSCADC_REG_IRQWAKEUP, restore);
-		tscadc_writel(ts_dev, TSCADC_REG_IRQCLR, TSCADC_IRQENB_HW_PEN);
-	}
-
-	/* context restore */
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ts_dev->ctrl);
-	/* Make sure ADC is powered up */
-	restore = tscadc_readl(ts_dev, TSCADC_REG_CTRL);
-	restore &= ~(TSCADC_CNTRLREG_POWERDOWN);
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL, restore);
-	tsc_idle_config(ts_dev);
-	tsc_step_config(ts_dev);
-	tscadc_writel(ts_dev, TSCADC_REG_FIFO0THR, ts_dev->steps_to_config);
-	restore = tscadc_readl(ts_dev, TSCADC_REG_CTRL);
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL,
-			(restore | TSCADC_CNTRLREG_TSCSSENB));
-
-	return 0;
-}
-
-static struct platform_driver ti_tsc_driver = {
-	.probe	  = tscadc_probe,
-	.remove	 = __devexit_p(tscadc_remove),
-	.driver	 = {
-		.name   = "tsc",
-		.owner  = THIS_MODULE,
-	},
-	.suspend = tscadc_suspend,
-	.resume  = tscadc_resume,
-};
-
-static int __init ti_tsc_init(void)
-{
-	return platform_driver_register(&ti_tsc_driver);
-}
-module_init(ti_tsc_init);
-
-static void __exit ti_tsc_exit(void)
-{
-	platform_driver_unregister(&ti_tsc_driver);
-}
-module_exit(ti_tsc_exit);
-
-MODULE_DESCRIPTION("TI touchscreen controller driver");
-MODULE_AUTHOR("Rachna Patil <rachna@ti.com>");
-MODULE_LICENSE("GPL");
diff --git a/include/linux/input/ti_tsc.h b/include/linux/input/ti_tsc.h
new file mode 100644
index 0000000..fa73aeb
--- /dev/null
+++ b/include/linux/input/ti_tsc.h
@@ -0,0 +1,18 @@
+/**
+ * struct tsc_data	Touchscreen wire configuration
+ * @wires:		Wires refer to application modes
+ *			i.e. 4/5/8 wire touchscreen support
+ *			on the platform
+ * @x_plate_resistance:	X plate resistance.
+ * @steps_to_configure: The sequencer supports a total of
+ *			16 programmable steps.
+ *			A step configured to read a single
+ *			co-ordinate value, can be applied
+ *			more number of times for better results.
+ */
+
+struct tsc_data {
+	int wires;
+	int x_plate_resistance;
+	int steps_to_configure;
+};
diff --git a/include/linux/input/ti_tscadc.h b/include/linux/input/ti_tscadc.h
deleted file mode 100644
index fa73aeb..0000000
--- a/include/linux/input/ti_tscadc.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/**
- * struct tsc_data	Touchscreen wire configuration
- * @wires:		Wires refer to application modes
- *			i.e. 4/5/8 wire touchscreen support
- *			on the platform
- * @x_plate_resistance:	X plate resistance.
- * @steps_to_configure: The sequencer supports a total of
- *			16 programmable steps.
- *			A step configured to read a single
- *			co-ordinate value, can be applied
- *			more number of times for better results.
- */
-
-struct tsc_data {
-	int wires;
-	int x_plate_resistance;
-	int steps_to_configure;
-};
-- 
1.7.11.2

