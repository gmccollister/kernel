From c842a281f0ae00cb28a8d75ae206b2b59597a8e3 Mon Sep 17 00:00:00 2001
From: "Philip, Avinash" <avinashphilip@ti.com>
Date: Mon, 17 Oct 2011 11:51:25 +0530
Subject: [PATCH 0827/1092] ARM: OMAP2+: nand: Updated JFFS2 clean marker
 offset.

JFFS2 clean marker offset used by Linux in case of 8-bit NAND device was
0x1 omap2 NAND driver. But 1st 2 bytes is used to indicate bad blocks by
manufacturers. So offset for JFFS2 clean markers is fixed to 0x2 in
omap2 NAND driver irrespective of 8/16 bit device.

Introduced new macro : JFFS2_CLEAN_MARKER_OFFSET to indicate 0x2 offset
for JFFS2 clean marker.

Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/mtd/nand/omap2.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c
index e0c2042..5fb710f 100644
--- a/drivers/mtd/nand/omap2.c
+++ b/drivers/mtd/nand/omap2.c
@@ -96,6 +96,7 @@
 #define P4o_s(a)	(TF(a & NAND_Ecc_P4o)		<< 1)
 
 #define MAX_HWECC_BYTES_OOB_64     24
+#define JFFS2_CLEAN_MARKER_OFFSET  0x2
 
 /* oob info generated runtime depending on ecc algorithm and layout selected */
 static struct nand_ecclayout omap_oobinfo;
@@ -1100,12 +1101,10 @@ static int __devinit omap_nand_probe(struct platform_device *pdev)
 	/* select ecc lyout */
 	if (info->nand.ecc.mode != NAND_ECC_SOFT) {
 
-		if (info->nand.options & NAND_BUSWIDTH_16)
-			offset = 2;
-		else {
-			offset = 1;
+		if (!(info->nand.options & NAND_BUSWIDTH_16))
 			info->nand.badblock_pattern = &bb_descrip_flashbased;
-		}
+
+		offset = JFFS2_CLEAN_MARKER_OFFSET;
 
 		if (info->mtd.oobsize == 64)
 			omap_oobinfo.eccbytes = info->nand.ecc.bytes *
-- 
1.7.11.2

