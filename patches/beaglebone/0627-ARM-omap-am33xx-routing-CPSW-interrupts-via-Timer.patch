From 783b98ac6de765044071456fc7fab3c31e473578 Mon Sep 17 00:00:00 2001
From: Vaibhav Hiremath <hvaibhav@ti.com>
Date: Sun, 27 Nov 2011 02:18:24 +0530
Subject: [PATCH 0627/1092] ARM:omap:am33xx: routing CPSW interrupts via Timer

This patch is added to route CPSW interrupts through ICSS module.
CPSW CPSW_RX and CPSW_TX interrupts are not directly used from CPSW
and instead they are routed through Timer module. This is done as an
software workaround for enabling interrupt pacing feature. As interrupt
Pacing works on C0_RX_PULSE interrupt connection to A8 INTC, which is
not connected to Cortex A8 interrupt controller directly due to hw issue,
it prevents interrupt pacing to work in AM33xx EVM. Therefore, Timer
capture module is used to pickup these interrupts and routed to A8 INTC.

Signed-off-by: Chandan Nath <chandan.nath@ti.com>
Signed-off-by: Afzal Mohammed <afzal@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/devices.c             | 11 ++----
 arch/arm/plat-omap/dmtimer.c              | 39 ++++++++++++++++++--
 arch/arm/plat-omap/include/plat/am33xx.h  |  4 ++
 arch/arm/plat-omap/include/plat/dmtimer.h |  3 ++
 drivers/net/ethernet/ti/cpsw.c            | 61 ++++++++++++++++++++++++++++---
 5 files changed, 102 insertions(+), 16 deletions(-)

diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 9db1d5d..9dcb188 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1166,9 +1166,6 @@ static int __init omap2_init_devices(void)
 }
 arch_initcall(omap2_init_devices);
 
-#define AM33XX_CPSW_BASE		(0x4A100000)
-#define AM33XX_CPSW_MDIO_BASE		(0x4A101000)
-#define AM33XX_CPSW_SS_BASE		(0x4A101200)
 #define AM33XX_EMAC_MDIO_FREQ		(1000000)
 
 static u64 am33xx_cpsw_dmamask = DMA_BIT_MASK(32);
@@ -1243,13 +1240,13 @@ static struct resource am33xx_cpsw_resources[] = {
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= AM33XX_IRQ_CPSW_RX,
-		.end	= AM33XX_IRQ_CPSW_RX,
+		.start	= AM33XX_IRQ_DMTIMER5,
+		.end	= AM33XX_IRQ_DMTIMER5,
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= AM33XX_IRQ_CPSW_TX,
-		.end	= AM33XX_IRQ_CPSW_TX,
+		.start	= AM33XX_IRQ_DMTIMER6,
+		.end	= AM33XX_IRQ_DMTIMER6,
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
diff --git a/arch/arm/plat-omap/dmtimer.c b/arch/arm/plat-omap/dmtimer.c
index f9adbbb..45f5b86 100644
--- a/arch/arm/plat-omap/dmtimer.c
+++ b/arch/arm/plat-omap/dmtimer.c
@@ -134,7 +134,6 @@ static void omap_dm_timer_reset(struct omap_dm_timer *timer)
 int omap_dm_timer_prepare(struct omap_dm_timer *timer)
 {
 	struct dmtimer_platform_data *pdata = timer->pdev->dev.platform_data;
-	int ret;
 
 	timer->fclk = clk_get(&timer->pdev->dev, "fck");
 	if (WARN_ON_ONCE(IS_ERR_OR_NULL(timer->fclk))) {
@@ -146,10 +145,8 @@ int omap_dm_timer_prepare(struct omap_dm_timer *timer)
 	if (pdata->needs_manual_reset)
 		omap_dm_timer_reset(timer);
 
-	ret = omap_dm_timer_set_source(timer, OMAP_TIMER_SRC_32_KHZ);
-
 	timer->posted = 1;
-	return ret;
+	return 0;
 }
 
 struct omap_dm_timer *omap_dm_timer_request(void)
@@ -494,6 +491,40 @@ int omap_dm_timer_set_pwm(struct omap_dm_timer *timer, int def_on,
 }
 EXPORT_SYMBOL_GPL(omap_dm_timer_set_pwm);
 
+int omap_dm_timer_set_capture(struct omap_dm_timer *timer, bool lht,
+				bool hlt, bool cm)
+{
+	u32 l;
+
+	if (unlikely(!timer))
+		return -EINVAL;
+
+	omap_dm_timer_enable(timer);
+	l = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);
+
+	if (lht && hlt)
+		l |= OMAP_TIMER_CTRL_TCM_BOTHEDGES;
+	else if (lht)
+		l |= OMAP_TIMER_CTRL_TCM_LOWTOHIGH;
+	else if (hlt)
+		l |= OMAP_TIMER_CTRL_TCM_HIGHTOLOW;
+	else
+		l &= ~OMAP_TIMER_CTRL_TCM_BOTHEDGES;
+
+	if (cm)
+		l |= OMAP_TIMER_CTRL_CAPTMODE;
+	else
+		l &= ~OMAP_TIMER_CTRL_CAPTMODE;
+
+	omap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);
+
+	/* Save the context */
+	timer->context.tclr = l;
+	omap_dm_timer_disable(timer);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_dm_timer_set_capture);
+
 int omap_dm_timer_set_prescaler(struct omap_dm_timer *timer, int prescaler)
 {
 	u32 l;
diff --git a/arch/arm/plat-omap/include/plat/am33xx.h b/arch/arm/plat-omap/include/plat/am33xx.h
index b13ddc2..475d020 100644
--- a/arch/arm/plat-omap/include/plat/am33xx.h
+++ b/arch/arm/plat-omap/include/plat/am33xx.h
@@ -70,6 +70,10 @@
 #define AM33XX_ASP0_BASE	0x48038000
 #define AM33XX_ASP1_BASE	0x4803C000
 
+#define AM33XX_CPSW_BASE       0x4A100000
+#define AM33XX_CPSW_MDIO_BASE  0x4A101000
+#define AM33XX_CPSW_SS_BASE    0x4A101200
+
 #define AM33XX_ICSS_BASE	0x4A300000
 #define AM33XX_ICSS_LEN		0x3FFFF
 
diff --git a/arch/arm/plat-omap/include/plat/dmtimer.h b/arch/arm/plat-omap/include/plat/dmtimer.h
index 9418f00..d9432b0 100644
--- a/arch/arm/plat-omap/include/plat/dmtimer.h
+++ b/arch/arm/plat-omap/include/plat/dmtimer.h
@@ -47,6 +47,7 @@
 
 /* timer interrupt enable bits */
 #define OMAP_TIMER_INT_CAPTURE			(1 << 2)
+#define OMAP_TIMER_INT_CAPTURE_RESET		(0 << 2)
 #define OMAP_TIMER_INT_OVERFLOW			(1 << 1)
 #define OMAP_TIMER_INT_MATCH			(1 << 0)
 
@@ -127,6 +128,8 @@ int omap_dm_timer_set_load(struct omap_dm_timer *timer, int autoreload, unsigned
 int omap_dm_timer_set_load_start(struct omap_dm_timer *timer, int autoreload, unsigned int value);
 int omap_dm_timer_set_match(struct omap_dm_timer *timer, int enable, unsigned int match);
 int omap_dm_timer_set_pwm(struct omap_dm_timer *timer, int def_on, int toggle, int trigger);
+int omap_dm_timer_set_capture(struct omap_dm_timer *timer,
+				bool lht, bool hlt, bool cm);
 int omap_dm_timer_set_prescaler(struct omap_dm_timer *timer, int prescaler);
 
 int omap_dm_timer_set_int_enable(struct omap_dm_timer *timer, unsigned int value);
diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 1f228f1..bcc9cff 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -28,7 +28,7 @@
 #include <linux/interrupt.h>
 
 #include <linux/cpsw.h>
-
+#include <plat/dmtimer.h>
 #include "cpsw_ale.h"
 #include "davinci_cpdma.h"
 
@@ -62,7 +62,6 @@ do {								\
 #define CPSW_POLL_WEIGHT	64
 #define CPSW_MIN_PACKET_SIZE	60
 #define CPSW_MAX_PACKET_SIZE	(1500 + 14 + 4 + 4)
-
 #define CPSW_PHY_SPEED		1000
 
 #define CPSW_IRQ_QUIRK
@@ -84,6 +83,18 @@ do {								\
 #define cpsw_disable_irq(priv) do { } while (0);
 #endif
 
+#define CPSW_CPDMA_EOI_REG	0x894
+#define CPSW_TIMER_MASK		0xA0908
+#define CPSW_TIMER_CAP_REG	0xFD0
+#define CPSW_RX_TIMER_REQ	5
+#define CPSW_TX_TIMER_REQ	6
+
+struct omap_dm_timer *stTimerRx;
+struct omap_dm_timer *stTimerTx;
+
+extern u32 omap_ctrl_readl(u16 offset);
+extern void omap_ctrl_writel(u32 val, u16 offset);
+
 static int debug_level;
 module_param(debug_level, int, 0);
 MODULE_PARM_DESC(debug_level, "cpsw debug level (NETIF_MSG bits)");
@@ -241,6 +252,8 @@ struct cpsw_priv {
 
 };
 
+static void __iomem *cpdma_base;
+
 static void cpsw_intr_enable(struct cpsw_priv *priv)
 {
 	__raw_writel(0xFF, &priv->ss_regs->tx_en);
@@ -308,6 +321,24 @@ void cpsw_rx_handler(void *token, int len, int status)
 
 }
 
+static void set_cpsw_dmtimer_clear(void)
+{
+	omap_dm_timer_write_status(stTimerRx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_write_status(stTimerTx, OMAP_TIMER_INT_CAPTURE);
+
+	omap_dm_timer_disable(stTimerRx);
+	omap_dm_timer_set_int_enable(stTimerRx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_set_capture(stTimerRx, 1, 0, 0);
+	omap_dm_timer_enable(stTimerRx);
+
+	omap_dm_timer_disable(stTimerTx);
+	omap_dm_timer_set_int_enable(stTimerTx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_set_capture(stTimerTx, 1, 0, 0);
+	omap_dm_timer_enable(stTimerTx);
+
+	return;
+}
+
 static irqreturn_t cpsw_interrupt(int irq, void *dev_id)
 {
 	struct cpsw_priv *priv = dev_id;
@@ -318,7 +349,6 @@ static irqreturn_t cpsw_interrupt(int irq, void *dev_id)
 		napi_schedule(&priv->napi);
 	}
 
-
 	return IRQ_HANDLED;
 }
 
@@ -327,17 +357,18 @@ static int cpsw_poll(struct napi_struct *napi, int budget)
 	struct cpsw_priv	*priv = napi_to_priv(napi);
 	int			num_tx, num_rx;
 
-
 	num_tx = cpdma_chan_process(priv->txch, 128);
 	num_rx = cpdma_chan_process(priv->rxch, budget);
 
 	if (num_rx || num_tx)
 		msg(dbg, intr, "poll %d rx, %d tx pkts\n", num_rx, num_tx);
 
-
 	if (num_rx < budget) {
 		napi_complete(napi);
 		cpdma_ctlr_eoi(priv->dma);
+		__raw_writel(0x1, cpdma_base + CPSW_CPDMA_EOI_REG);
+		__raw_writel(0x2, cpdma_base + CPSW_CPDMA_EOI_REG);
+		set_cpsw_dmtimer_clear();
 		cpsw_intr_enable(priv);
 		cpsw_enable_irq(priv);
 	}
@@ -894,6 +925,12 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 	struct resource			*res;
 	int ret = 0, i, k = 0;
 
+	cpdma_base = ioremap(AM33XX_CPSW_BASE, SZ_4K);
+	if (WARN_ON(!cpdma_base)) {
+		printk(KERN_ERR"errror: %s: ioremap", __func__);
+		return -ENODEV;
+	}
+
 	if (!data) {
 		pr_err("cpsw: platform data missing\n");
 		return -ENODEV;
@@ -993,6 +1030,20 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 
 	for_each_slave(priv, cpsw_slave_init, priv);
 
+	omap_ctrl_writel(CPSW_TIMER_MASK, CPSW_TIMER_CAP_REG);
+
+	/* Enable Timer */
+	stTimerRx = omap_dm_timer_request_specific(CPSW_RX_TIMER_REQ);
+	omap_dm_timer_set_int_enable(stTimerRx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_set_capture(stTimerRx, 1, 0, 0);
+	omap_dm_timer_enable(stTimerRx);
+
+	/* Enable Timer */
+	stTimerTx = omap_dm_timer_request_specific(CPSW_TX_TIMER_REQ);
+	omap_dm_timer_set_int_enable(stTimerTx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_set_capture(stTimerTx, 1, 0, 0);
+	omap_dm_timer_enable(stTimerTx);
+
 	memset(&dma_params, 0, sizeof(dma_params));
 	dma_params.dev			= &pdev->dev;
 	dma_params.dmaregs		= (void __iomem *)(((u32)priv->regs) +
-- 
1.7.11.2

