From 150d775dfb5f0f997b223bbd3ae12b2b789dfc74 Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Mon, 10 Oct 2011 20:40:49 +0530
Subject: [PATCH 0584/1092] ARM:omap3:am335x evm: Add support for RTC

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/board-am335xevm.c | 86 +++++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/mux33xx.c         |  2 +-
 2 files changed, 87 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index 77137da..a711edd 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -1151,10 +1151,96 @@ static void __init am335x_evm_i2c_init(void)
 				ARRAY_SIZE(am335x_i2c_boardinfo));
 }
 
+static struct resource am335x_rtc_resources[] = {
+	{
+		.start		= AM33XX_RTC_BASE,
+		.end		= AM33XX_RTC_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{ /* timer irq */
+		.start		= AM33XX_IRQ_RTC_TIMER,
+		.end		= AM33XX_IRQ_RTC_TIMER,
+		.flags		= IORESOURCE_IRQ,
+	},
+	{ /* alarm irq */
+		.start		= AM33XX_IRQ_RTC_ALARM,
+		.end		= AM33XX_IRQ_RTC_ALARM,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device am335x_rtc_device = {
+	.name           = "omap_rtc",
+	.id             = -1,
+	.num_resources	= ARRAY_SIZE(am335x_rtc_resources),
+	.resource	= am335x_rtc_resources,
+};
+
+static int am335x_rtc_init(void)
+{
+	void __iomem *base;
+	struct clk *clk;
+
+	clk = clk_get(NULL, "rtc_fck");
+	if (IS_ERR(clk)) {
+		pr_err("rtc : Failed to get RTC clock\n");
+		return -1;
+	}
+
+	if (clk_enable(clk)) {
+		pr_err("rtc: Clock Enable Failed\n");
+		return -1;
+	}
+
+	base = ioremap(AM33XX_RTC_BASE, SZ_4K);
+
+	if (WARN_ON(!base))
+		return -ENOMEM;
+
+	/* Unlock the rtc's registers */
+	__raw_writel(0x83e70b13, base + 0x6c);
+	__raw_writel(0x95a4f1e0, base + 0x70);
+
+	/*
+	 * Enable the 32K OSc
+	 * TODO: Need a better way to handle this
+	 * Since we want the clock to be running before mmc init
+	 * we need to do it before the rtc probe happens
+	 */
+	__raw_writel(0x48, base + 0x54);
+
+	iounmap(base);
+
+	return  platform_device_register(&am335x_rtc_device);
+}
+
+/* Enable clkout2 */
+static struct pinmux_config clkout2_pin_mux[] = {
+	{"xdma_event_intr1.clkout2", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
+static void __init clkout2_enable(void)
+{
+	struct clk *ck_32;
+
+	ck_32 = clk_get(NULL, "clkout2_ck");
+	if (IS_ERR(ck_32)) {
+		pr_err("Cannot clk_get ck_32\n");
+		return;
+	}
+
+	clk_enable(ck_32);
+
+	setup_pin_mux(clkout2_pin_mux);
+}
+
 static void __init am335x_evm_init(void)
 {
 	am33xx_mux_init(board_mux);
 	omap_serial_init();
+	am335x_rtc_init();
+	clkout2_enable();
 	am335x_evm_i2c_init();
 	omap_sdrc_init(NULL, NULL);
 	usb_musb_init(&musb_board_data);
diff --git a/arch/arm/mach-omap2/mux33xx.c b/arch/arm/mach-omap2/mux33xx.c
index f4c052b..6679024 100644
--- a/arch/arm/mach-omap2/mux33xx.c
+++ b/arch/arm/mach-omap2/mux33xx.c
@@ -360,7 +360,7 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 		"xdma_event_intr0", NULL, NULL, NULL,
 		"spi1_cs1", NULL, NULL, NULL),
 	_AM33XX_MUXENTRY(XDMA_EVENT_INTR1, 0,
-		NULL, NULL, NULL, NULL,
+		"xdma_event_intr1", NULL, NULL, "clkout2",
 		NULL, NULL, NULL, NULL),
 	_AM33XX_MUXENTRY(WARMRSTN, 0,
 		NULL, NULL, NULL, NULL,
-- 
1.7.11.2

