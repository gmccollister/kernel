From 8b621b3617e5d7379c09f3de60c9b4ab3dc945cf Mon Sep 17 00:00:00 2001
From: Mugunthan V N <mugunthanvnm@ti.com>
Date: Mon, 12 Sep 2011 14:59:23 +0530
Subject: [PATCH 0995/1092] net: driver: ethernet: cpsw_ale: Add helper
 functions for VLAN ALE implementation

* Add helper functions for VLAN ALE implementations for Add, Delete
  Dump VLAN related ALE entries
* Enhanced Multicast add helper function to support Super Bit and Multicast
  state to ALE table entry

Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c     |   4 +-
 drivers/net/ethernet/ti/cpsw_ale.c | 220 ++++++++++++++++++++++++++++++++++---
 drivers/net/ethernet/ti/cpsw_ale.h |  14 ++-
 3 files changed, 221 insertions(+), 17 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 1f96983..a5cac35 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -629,7 +629,7 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 
 	slave_port = cpsw_get_slave_port(priv, slave->slave_num);
 	cpsw_ale_add_mcast(priv->ale, priv->ndev->broadcast,
-			   1 << slave_port);
+			   1 << slave_port, 0, 0);
 
 	slave->phy = phy_connect(priv->ndev, slave->data->phy_id,
 				 &cpsw_adjust_link, 0, slave->data->phy_if);
@@ -665,7 +665,7 @@ static void cpsw_init_host_port(struct cpsw_priv *priv)
 			  0);
 			   /* ALE_SECURE); */
 	cpsw_ale_add_mcast(priv->ale, priv->ndev->broadcast,
-			   1 << priv->host_port);
+			   1 << priv->host_port, 0, 0);
 }
 
 static int cpsw_ndo_open(struct net_device *ndev)
diff --git a/drivers/net/ethernet/ti/cpsw_ale.c b/drivers/net/ethernet/ti/cpsw_ale.c
index 9639c31..43c8aac 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@ -156,7 +156,7 @@ static int cpsw_ale_write(struct cpsw_ale *ale, int idx, u32 *ale_entry)
 	return idx;
 }
 
-static int cpsw_ale_match_addr(struct cpsw_ale *ale, u8* addr)
+static int cpsw_ale_match_addr(struct cpsw_ale *ale, u8* addr, u16 vid)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS];
 	int type, idx;
@@ -168,6 +168,8 @@ static int cpsw_ale_match_addr(struct cpsw_ale *ale, u8* addr)
 		type = cpsw_ale_get_entry_type(ale_entry);
 		if (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)
 			continue;
+		if (cpsw_ale_get_vlan_id(ale_entry) != vid)
+			continue;
 		cpsw_ale_get_addr(ale_entry, entry_addr);
 		if (memcmp(entry_addr, addr, 6) == 0)
 			return idx;
@@ -175,6 +177,22 @@ static int cpsw_ale_match_addr(struct cpsw_ale *ale, u8* addr)
 	return -ENOENT;
 }
 
+static int cpsw_ale_match_vlan(struct cpsw_ale *ale, u16 vid)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS];
+	int type, idx;
+
+	for (idx = 0; idx < ale->ale_entries; idx++) {
+		cpsw_ale_read(ale, idx, ale_entry);
+		type = cpsw_ale_get_entry_type(ale_entry);
+		if (type != ALE_TYPE_VLAN)
+			continue;
+		if (cpsw_ale_get_vlan_id(ale_entry) == vid)
+			return idx;
+	}
+	return -ENOENT;
+}
+
 static int cpsw_ale_match_free(struct cpsw_ale *ale)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS];
@@ -294,6 +312,25 @@ static int cpsw_ale_dump_ucast(u32 *ale_entry, char *buf, int len)
 	return outlen;
 }
 
+static int cpsw_ale_dump_vlan(u32 *ale_entry, char *buf, int len)
+{
+	int outlen = 0;
+	int untag_force = cpsw_ale_get_vlan_untag_force(ale_entry);
+	int reg_mcast   = cpsw_ale_get_vlan_reg_mcast(ale_entry);
+	int unreg_mcast = cpsw_ale_get_vlan_unreg_mcast(ale_entry);
+	int member_list = cpsw_ale_get_vlan_member_list(ale_entry);
+
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "vlanuntag: %x, ", untag_force);
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "vlanregmcast: %x, ", reg_mcast);
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "vlanunregmcast: %x, ", unreg_mcast);
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "vlanmemberlist: %x\n", member_list);
+	return outlen;
+}
+
 static int cpsw_ale_dump_entry(int idx, u32 *ale_entry, char *buf, int len)
 {
 	int type, outlen = 0;
@@ -315,19 +352,25 @@ static int cpsw_ale_dump_entry(int idx, u32 *ale_entry, char *buf, int len)
 	outlen += snprintf(buf + outlen, len - outlen,
 			   "type: %s(%d), ", str_type[type], type);
 
-	cpsw_ale_get_addr(ale_entry, addr);
-	outlen += snprintf(buf + outlen, len - outlen,
-			   "addr: " ADDR_FMT_STR ", ", ADDR_FMT_ARGS(addr));
-
 	if (type == ALE_TYPE_VLAN || type == ALE_TYPE_VLAN_ADDR) {
 		outlen += snprintf(buf + outlen, len - outlen, "vlan: %d, ",
 				   cpsw_ale_get_vlan_id(ale_entry));
 	}
 
-	outlen += cpsw_ale_get_mcast(ale_entry) ?
-		  cpsw_ale_dump_mcast(ale_entry, buf + outlen, len - outlen) :
-		  cpsw_ale_dump_ucast(ale_entry, buf + outlen, len - outlen);
-
+	if (type == ALE_TYPE_ADDR || type == ALE_TYPE_VLAN_ADDR) {
+		cpsw_ale_get_addr(ale_entry, addr);
+		outlen += snprintf(buf + outlen, len - outlen,
+			"addr: " ADDR_FMT_STR ", ", ADDR_FMT_ARGS(addr));
+		outlen += cpsw_ale_get_mcast(ale_entry) ?
+			cpsw_ale_dump_mcast(ale_entry, buf + outlen,
+						len - outlen) :
+			cpsw_ale_dump_ucast(ale_entry, buf + outlen,
+						len - outlen);
+	} else {
+		/* type == ALE_TYPE_VLAN */
+		outlen += cpsw_ale_dump_vlan(ale_entry, buf + outlen,
+					     len - outlen);
+	}
 	return outlen;
 }
 
@@ -343,7 +386,7 @@ int cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port, int flags)
 	cpsw_ale_set_blocked(ale_entry, (flags & ALE_BLOCKED) ? 1 : 0);
 	cpsw_ale_set_port_num(ale_entry, port);
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, 0);
 	if (idx < 0)
 		idx = cpsw_ale_match_free(ale);
 	if (idx < 0)
@@ -361,7 +404,7 @@ int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port)
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
 	int idx;
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, 0);
 	if (idx < 0)
 		return -ENOENT;
 
@@ -371,18 +414,21 @@ int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port)
 }
 EXPORT_SYMBOL_GPL(cpsw_ale_del_ucast);
 
-int cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask)
+int cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,
+			int super, int mcast_state)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
 	int idx, mask;
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, 0);
 	if (idx >= 0)
 		cpsw_ale_read(ale, idx, ale_entry);
 
 	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);
 	cpsw_ale_set_addr(ale_entry, addr);
 	cpsw_ale_set_mcast_state(ale_entry, ALE_MCAST_FWD_2);
+	cpsw_ale_set_super(ale_entry, super);
+	cpsw_ale_set_mcast_state(ale_entry, mcast_state);
 
 	mask = cpsw_ale_get_port_mask(ale_entry);
 	port_mask |= mask;
@@ -405,7 +451,153 @@ int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask)
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
 	int idx, mask;
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, 0);
+	if (idx < 0)
+		return -EINVAL;
+
+	cpsw_ale_read(ale, idx, ale_entry);
+	mask = cpsw_ale_get_port_mask(ale_entry);
+	port_mask = mask & ~port_mask;
+
+	if (port_mask == BIT(ale->ale_ports))
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
+	else
+		cpsw_ale_set_port_mask(ale_entry, port_mask);
+
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+int cpsw_ale_add_vlan(struct cpsw_ale *ale, u16 vid, int port, int untag,
+		      int reg_mcast, int unreg_mcast)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx;
+
+	idx = cpsw_ale_match_vlan(ale, vid);
+	if (idx >= 0)
+		cpsw_ale_read(ale, idx, ale_entry);
+
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN);
+	cpsw_ale_set_vlan_id(ale_entry, vid);
+
+	cpsw_ale_set_vlan_untag_force(ale_entry, untag);
+	cpsw_ale_set_vlan_reg_mcast(ale_entry, reg_mcast);
+	cpsw_ale_set_vlan_unreg_mcast(ale_entry, unreg_mcast);
+	cpsw_ale_set_vlan_member_list(ale_entry, port);
+
+	if (idx < 0)
+		idx = cpsw_ale_match_free(ale);
+	if (idx < 0)
+		idx = cpsw_ale_find_ageable(ale);
+	if (idx < 0)
+		return -ENOMEM;
+
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+int cpsw_ale_del_vlan(struct cpsw_ale *ale, u16 vid, int port)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx, mask;
+
+	idx = cpsw_ale_match_vlan(ale, vid);
+	if (idx < 0)
+		return -ENOENT;
+
+	cpsw_ale_read(ale, idx, ale_entry);
+
+	mask  = cpsw_ale_get_vlan_member_list(ale_entry);
+	mask &= ~port;
+	if (!mask)
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
+	else
+		cpsw_ale_set_vlan_member_list(ale_entry, mask);
+
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+int cpsw_ale_vlan_add_ucast(struct cpsw_ale *ale, u8 *addr, int port,
+				int flags, u16 vid)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx;
+
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN_ADDR);
+	cpsw_ale_set_addr(ale_entry, addr);
+	cpsw_ale_set_ucast_type(ale_entry, ALE_UCAST_PERSISTANT);
+	cpsw_ale_set_secure(ale_entry, (flags & ALE_SECURE) ? 1 : 0);
+	cpsw_ale_set_blocked(ale_entry, (flags & ALE_BLOCKED) ? 1 : 0);
+	cpsw_ale_set_port_num(ale_entry, port);
+	cpsw_ale_set_vlan_id(ale_entry, vid);
+
+	idx = cpsw_ale_match_addr(ale, addr, vid);
+	if (idx < 0)
+		idx = cpsw_ale_match_free(ale);
+	if (idx < 0)
+		idx = cpsw_ale_find_ageable(ale);
+	if (idx < 0)
+		return -ENOMEM;
+
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+int cpsw_ale_vlan_del_ucast(struct cpsw_ale *ale, u8 *addr, int port, u16 vid)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx;
+
+	idx = cpsw_ale_match_addr(ale, addr, vid);
+	if (idx < 0)
+		return -ENOENT;
+
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+int cpsw_ale_vlan_add_mcast(struct cpsw_ale *ale, u8 *addr,
+		int port_mask, u16 vid, int super, int mcast_state)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx, mask;
+
+	idx = cpsw_ale_match_addr(ale, addr, vid);
+	if (idx >= 0)
+		cpsw_ale_read(ale, idx, ale_entry);
+
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN_ADDR);
+	cpsw_ale_set_addr(ale_entry, addr);
+	cpsw_ale_set_mcast_state(ale_entry, ALE_MCAST_FWD_2);
+	cpsw_ale_set_vlan_id(ale_entry, vid);
+	cpsw_ale_set_super(ale_entry, super);
+	cpsw_ale_set_mcast_state(ale_entry, mcast_state);
+
+	mask = cpsw_ale_get_port_mask(ale_entry);
+	port_mask |= mask;
+	cpsw_ale_set_port_mask(ale_entry, port_mask);
+
+	if (idx < 0)
+		idx = cpsw_ale_match_free(ale);
+	if (idx < 0)
+		idx = cpsw_ale_find_ageable(ale);
+	if (idx < 0)
+		return -ENOMEM;
+
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+int cpsw_ale_vlan_del_mcast(struct cpsw_ale *ale, u8 *addr,
+				int port_mask, u16 vid)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx, mask;
+
+	idx = cpsw_ale_match_addr(ale, addr, vid);
 	if (idx < 0)
 		return -EINVAL;
 
diff --git a/drivers/net/ethernet/ti/cpsw_ale.h b/drivers/net/ethernet/ti/cpsw_ale.h
index f064a04a..b62d89f 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.h
+++ b/drivers/net/ethernet/ti/cpsw_ale.h
@@ -83,8 +83,20 @@ int cpsw_ale_set_ageout(struct cpsw_ale *ale, int ageout);
 int cpsw_ale_flush(struct cpsw_ale *ale, int port_mask);
 int cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port, int flags);
 int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port);
-int cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask);
+int cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,
+			int super, int mcast_state);
 int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask);
+int cpsw_ale_add_vlan(struct cpsw_ale *ale, u16 vid, int port, int untag,
+			int reg_mcast, int unreg_mcast);
+int cpsw_ale_del_vlan(struct cpsw_ale *ale, u16 vid, int port);
+int cpsw_ale_vlan_add_ucast(struct cpsw_ale *ale, u8 *addr, int port,
+			int flags, u16 vid);
+int cpsw_ale_vlan_del_ucast(struct cpsw_ale *ale, u8 *addr, int port,
+			u16 vid);
+int cpsw_ale_vlan_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,
+			u16 vid, int super, int mcast_state);
+int cpsw_ale_vlan_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,
+			u16 vid);
 
 int cpsw_ale_control_get(struct cpsw_ale *ale, int port, int control);
 int cpsw_ale_control_set(struct cpsw_ale *ale, int port,
-- 
1.7.11.2

