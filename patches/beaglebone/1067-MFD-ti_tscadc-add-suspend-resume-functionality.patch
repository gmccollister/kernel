From 49f9f0f10d2c1bcf4868a51456e7f98dc3bb5eae Mon Sep 17 00:00:00 2001
From: "Patil, Rachna" <rachna@ti.com>
Date: Wed, 29 Aug 2012 15:31:39 +0530
Subject: [PATCH 1067/1092] MFD: ti_tscadc: add suspend/resume functionality

This patch adds support for suspend/resume of
TSC/ADC MFDevice.

Signed-off-by: Patil, Rachna <rachna@ti.com>
---
 drivers/input/touchscreen/ti_tsc.c | 35 +++++++++++++++++++++++++++++++++++
 drivers/mfd/ti_tscadc.c            | 35 ++++++++++++++++++++++++++++++++++-
 drivers/staging/iio/adc/ti_adc.c   | 32 ++++++++++++++++++++++++++++++++
 3 files changed, 101 insertions(+), 1 deletion(-)

diff --git a/drivers/input/touchscreen/ti_tsc.c b/drivers/input/touchscreen/ti_tsc.c
index 28db89a..47f5b8e 100644
--- a/drivers/input/touchscreen/ti_tsc.c
+++ b/drivers/input/touchscreen/ti_tsc.c
@@ -374,6 +374,39 @@ static int __devexit tscadc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int tsc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct ti_tscadc_dev	*tscadc_dev = pdev->dev.platform_data;
+	struct tscadc		*ts_dev = tscadc_dev->tsc;
+	unsigned int idle;
+
+	if (device_may_wakeup(tscadc_dev->dev)) {
+		idle = tscadc_readl(ts_dev, TSCADC_REG_IRQENABLE);
+		tscadc_writel(ts_dev, TSCADC_REG_IRQENABLE,
+				(idle | TSCADC_IRQENB_HW_PEN));
+		tscadc_writel(ts_dev, TSCADC_REG_IRQWAKEUP,
+				TSCADC_IRQWKUP_ENB);
+	}
+	return 0;
+}
+
+static int tsc_resume(struct platform_device *pdev)
+{
+	struct ti_tscadc_dev	*tscadc_dev = pdev->dev.platform_data;
+	struct tscadc		*ts_dev = tscadc_dev->tsc;
+
+	if (device_may_wakeup(tscadc_dev->dev)) {
+		tscadc_writel(ts_dev, TSCADC_REG_IRQWAKEUP,
+				0x00);
+		tscadc_writel(ts_dev, TSCADC_REG_IRQCLR,
+				TSCADC_IRQENB_HW_PEN);
+	}
+	tsc_step_config(ts_dev);
+	tscadc_writel(ts_dev, TSCADC_REG_FIFO0THR,
+			ts_dev->steps_to_config);
+	return 0;
+}
+
 static struct platform_driver ti_tsc_driver = {
 	.probe	  = tscadc_probe,
 	.remove	 = __devexit_p(tscadc_remove),
@@ -381,6 +414,8 @@ static struct platform_driver ti_tsc_driver = {
 		.name   = "tsc",
 		.owner  = THIS_MODULE,
 	},
+	.suspend = tsc_suspend,
+	.resume = tsc_resume,
 };
 
 static int __init ti_tsc_init(void)
diff --git a/drivers/mfd/ti_tscadc.c b/drivers/mfd/ti_tscadc.c
index d57675e..5fd33ec 100644
--- a/drivers/mfd/ti_tscadc.c
+++ b/drivers/mfd/ti_tscadc.c
@@ -170,6 +170,7 @@ static int __devinit ti_tscadc_probe(struct platform_device *pdev)
 	if (err < 0)
 		goto err_fail;
 
+	device_init_wakeup(&pdev->dev, true);
 	platform_set_drvdata(pdev, tscadc);
 	return 0;
 
@@ -206,6 +207,37 @@ static int __devexit ti_tscadc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int tscadc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct ti_tscadc_dev	*tscadc_dev = platform_get_drvdata(pdev);
+
+	tscadc_writel(tscadc_dev, TSCADC_REG_SE, 0x00);
+	pm_runtime_put_sync(&pdev->dev);
+	return 0;
+}
+
+static int tscadc_resume(struct platform_device *pdev)
+{
+	struct ti_tscadc_dev	*tscadc_dev = platform_get_drvdata(pdev);
+	unsigned int restore, ctrl;
+
+	pm_runtime_get_sync(&pdev->dev);
+
+	/* context restore */
+	ctrl = TSCADC_CNTRLREG_STEPCONFIGWRT |
+			TSCADC_CNTRLREG_TSCENB |
+			TSCADC_CNTRLREG_STEPID |
+			TSCADC_CNTRLREG_4WIRE;
+	tscadc_writel(tscadc_dev, TSCADC_REG_CTRL, ctrl);
+	tscadc_idle_config(tscadc_dev);
+	tscadc_writel(tscadc_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
+	restore = tscadc_readl(tscadc_dev, TSCADC_REG_CTRL);
+	tscadc_writel(tscadc_dev, TSCADC_REG_CTRL,
+			(restore | TSCADC_CNTRLREG_TSCSSENB));
+
+	return 0;
+}
+
 static struct platform_driver ti_tscadc_driver = {
 	.driver = {
 		.name   = "ti_tscadc",
@@ -213,7 +245,8 @@ static struct platform_driver ti_tscadc_driver = {
 	},
 	.probe	= ti_tscadc_probe,
 	.remove	= __devexit_p(ti_tscadc_remove),
-
+	.suspend = tscadc_suspend,
+	.resume = tscadc_resume,
 };
 
 module_platform_driver(ti_tscadc_driver);
diff --git a/drivers/staging/iio/adc/ti_adc.c b/drivers/staging/iio/adc/ti_adc.c
index 483f6ae..1628456 100644
--- a/drivers/staging/iio/adc/ti_adc.c
+++ b/drivers/staging/iio/adc/ti_adc.c
@@ -200,6 +200,36 @@ static int __devexit tiadc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int adc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct ti_tscadc_dev   *tscadc_dev = pdev->dev.platform_data;
+	struct adc_device	*adc_dev = tscadc_dev->adc;
+	unsigned int idle;
+
+	if (!device_may_wakeup(tscadc_dev->dev)) {
+		idle = adc_readl(adc_dev, TSCADC_REG_CTRL);
+		idle &= ~(TSCADC_CNTRLREG_TSCSSENB);
+		adc_writel(adc_dev, TSCADC_REG_CTRL, (idle |
+				TSCADC_CNTRLREG_POWERDOWN));
+	}
+	return 0;
+}
+
+static int adc_resume(struct platform_device *pdev)
+{
+	struct ti_tscadc_dev   *tscadc_dev = pdev->dev.platform_data;
+	struct adc_device	*adc_dev = tscadc_dev->adc;
+	unsigned int restore;
+
+	/* Make sure ADC is powered up */
+	restore = adc_readl(adc_dev, TSCADC_REG_CTRL);
+	restore &= ~(TSCADC_CNTRLREG_POWERDOWN);
+	adc_writel(adc_dev, TSCADC_REG_CTRL, restore);
+
+	adc_step_config(adc_dev);
+	return 0;
+}
+
 static struct platform_driver tiadc_driver = {
 	.driver = {
 		.name   = "tiadc",
@@ -207,6 +237,8 @@ static struct platform_driver tiadc_driver = {
 	},
 	.probe          = tiadc_probe,
 	.remove         = __devexit_p(tiadc_remove),
+	.suspend = adc_suspend,
+	.resume = adc_resume,
 };
 
 module_platform_driver(tiadc_driver);
-- 
1.7.11.2

