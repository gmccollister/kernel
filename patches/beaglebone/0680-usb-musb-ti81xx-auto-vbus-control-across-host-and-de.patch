From aef44c12ae55d66d0fcca7788ce73c1f5aaec555 Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Thu, 22 Dec 2011 16:02:59 +0530
Subject: [PATCH 0680/1092] usb: musb: ti81xx: auto vbus control across host
 and device mode

Automatically control vbus using timer. Set the session bit periodically in a timer
context when nothing is connected to usb port. If mini-A is connected then Vbus will
get switched on and if mini-B is connected then Vbus will nto be driven.

Kill the timer when a device is attached in host mode or port is connected to external
host and revive the timer as soon as disconnect happens.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
---
 drivers/usb/musb/musb_core.c |  1 -
 drivers/usb/musb/ti81xx.c    | 19 ++++++++++++-------
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index fb5da83..86cc08d 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -969,7 +969,6 @@ void musb_start(struct musb *musb)
 
 	musb->is_active = 0;
 	devctl = musb_readb(regs, MUSB_DEVCTL);
-	devctl &= ~MUSB_DEVCTL_SESSION;
 
 	if (is_otg_enabled(musb)) {
 		/* session started after:
diff --git a/drivers/usb/musb/ti81xx.c b/drivers/usb/musb/ti81xx.c
index 5a5e07c..6f3adcd 100644
--- a/drivers/usb/musb/ti81xx.c
+++ b/drivers/usb/musb/ti81xx.c
@@ -594,12 +594,14 @@ static void otg_timer(unsigned long _musb)
 		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
-			MUSB_DEV_MODE(musb);
-		} else {
+		if (devctl & MUSB_DEVCTL_HM) {
 			musb->xceiv->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
+		} else {
+			musb->xceiv->state = OTG_STATE_B_IDLE;
+			MUSB_DEV_MODE(musb);
+			mod_timer(&musb->otg_workaround,
+					jiffies + POLL_SECONDS * HZ);
 		}
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
@@ -635,11 +637,14 @@ static void otg_timer(unsigned long _musb)
 		 * SRP but clearly it doesn't.
 		 */
 		devctl = musb_readb(mregs, MUSB_DEVCTL);
-		if (devctl & MUSB_DEVCTL_BDEVICE)
+		if (devctl & MUSB_DEVCTL_HM) {
+			musb->xceiv->state = OTG_STATE_A_IDLE;
+		} else {
 			mod_timer(&musb->otg_workaround,
 					jiffies + POLL_SECONDS * HZ);
-		else
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl |
+				MUSB_DEVCTL_SESSION);
+		}
 		break;
 	default:
 		break;
-- 
1.7.11.2

