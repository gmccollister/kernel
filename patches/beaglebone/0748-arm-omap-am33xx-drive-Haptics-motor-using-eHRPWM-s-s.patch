From 162af1b552e6b11fd28ab176def6a62ecf135a6d Mon Sep 17 00:00:00 2001
From: "Philip, Avinash" <avinashphilip@ti.com>
Date: Tue, 24 Jan 2012 19:03:04 +0530
Subject: [PATCH 0748/1092] arm:omap:am33xx - drive Haptics motor using
 eHRPWM's sysfs interface.

Since Haptics doesn't have its own driver(yet), currently Haptics can
be tested using eHRPWM's sysfs interface.

This patch adds support for driving Haptics motor connected to
eHRPWM Instance 2 channel 2.

According to datasheet, the Haptic Motors Max RPM is 15000 RPM. Driving
the Motor above MAX RPM may spoil the Motor.
This patch limits the eHRPWM max freq to 250Hz. This can be changed
from platform data.

Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
---
 arch/arm/mach-omap2/board-am335xevm.c | 17 +++++++++++++++++
 arch/arm/mach-omap2/devices.c         | 17 ++++++++++++++---
 arch/arm/mach-omap2/devices.h         |  1 +
 arch/arm/mach-omap2/mux33xx.c         |  2 +-
 drivers/pwm/ehrpwm.c                  | 16 +++++++++++++++-
 include/linux/pwm/pwm.h               |  9 +++++++++
 6 files changed, 57 insertions(+), 5 deletions(-)

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index e9e2c28..93ccc40 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -349,6 +349,12 @@ static u32 am335x_get_profile_selection(void)
 		return val & 0x7;
 }
 
+static struct pinmux_config haptics_pin_mux[] = {
+	{"gpmc_ad9.ehrpwm2B",		OMAP_MUX_MODE4 |
+		AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
 /* Module pin mux for LCDC */
 static struct pinmux_config lcdc_pin_mux[] = {
 	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
@@ -985,6 +991,16 @@ static void uart2_init(int evm_id, int profile)
 	return;
 }
 
+/* setup haptics */
+#define HAPTICS_MAX_FREQ (250)
+
+static void haptics_init(int evm_id, int profile)
+{
+	setup_pin_mux(haptics_pin_mux);
+	register_ehrpwm(HAPTICS_MAX_FREQ);
+	return;
+}
+
 /* NAND partition information */
 static struct mtd_partition am335x_nand_partitions[] = {
 /* All the partition sizes are listed in terms of NAND block size */
@@ -1653,6 +1669,7 @@ static struct evm_dev_cfg gen_purp_evm_dev_cfg[] = {
 	{matrix_keypad_init, DEV_ON_DGHTR_BRD, PROFILE_0},
 	{volume_keys_init,  DEV_ON_DGHTR_BRD, PROFILE_0},
 	{uart2_init,	DEV_ON_DGHTR_BRD, PROFILE_3},
+	{haptics_init,	DEV_ON_DGHTR_BRD, (PROFILE_4)},
 	{NULL, 0, 0},
 };
 
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index d73023f..4b137e9 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1253,16 +1253,27 @@ struct platform_device am335x_epwm2_device = {
 void __init am335x_register_epwm(void)
 {
 
-	__raw_writew((PWMSS2_TBCLKEN | PWMSS1_TBCLKEN | PWMSS0_TBCLKEN),
+	__raw_writew((PWMSS1_TBCLKEN | PWMSS0_TBCLKEN),
 			AM33XX_CTRL_REGADDR(AM33XX_PWMSS_CTRL));
 	am335x_pwmss_config0.version = PWM_VERSION_1;
 	am335x_pwmss_config1.version = PWM_VERSION_1;
-	am335x_pwmss_config2.version = PWM_VERSION_1;
 	sema_init(&am335x_pwmss_config0.config_semaphore, 1);
 	sema_init(&am335x_pwmss_config1.config_semaphore, 1);
-	sema_init(&am335x_pwmss_config2.config_semaphore, 1);
 	platform_device_register(&am335x_epwm0_device);
 	platform_device_register(&am335x_epwm1_device);
+}
+
+
+void register_ehrpwm(int max_freq)
+{
+	int val;
+
+	val = __raw_readw(AM33XX_CTRL_REGADDR(AM33XX_PWMSS_CTRL));
+	val |= PWMSS2_TBCLKEN;
+	__raw_writew(val, AM33XX_CTRL_REGADDR(AM33XX_PWMSS_CTRL));
+	am335x_pwmss_config2.chan_attrib[1].max_freq = max_freq;
+	sema_init(&am335x_pwmss_config2.config_semaphore, 1);
+	am335x_pwmss_config2.version = PWM_VERSION_1;
 	platform_device_register(&am335x_epwm2_device);
 }
 
diff --git a/arch/arm/mach-omap2/devices.h b/arch/arm/mach-omap2/devices.h
index 10e4603..e086839 100644
--- a/arch/arm/mach-omap2/devices.h
+++ b/arch/arm/mach-omap2/devices.h
@@ -17,5 +17,6 @@ struct isp_platform_data;
 int omap3_init_camera(struct isp_platform_data *pdata);
 
 void __init am335x_register_mcasp1(struct snd_platform_data *pdata);
+extern void register_ehrpwm(int max_freq);
 
 #endif
diff --git a/arch/arm/mach-omap2/mux33xx.c b/arch/arm/mach-omap2/mux33xx.c
index f3bc09a..58d3edd 100644
--- a/arch/arm/mach-omap2/mux33xx.c
+++ b/arch/arm/mach-omap2/mux33xx.c
@@ -58,7 +58,7 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 		NULL, NULL, NULL, NULL),
 	_AM33XX_MUXENTRY(GPMC_AD9, 0,
 		"gpmc_ad9", "lcd_data17", "mmc1_dat1", "mmc2_dat5",
-		NULL, NULL, NULL, NULL),
+		"ehrpwm2B", NULL, NULL, NULL),
 	_AM33XX_MUXENTRY(GPMC_AD10, 0,
 		"gpmc_ad10", "lcd_data18", "mmc1_dat2", "mmc2_dat6",
 		NULL, NULL, NULL, NULL),
diff --git a/drivers/pwm/ehrpwm.c b/drivers/pwm/ehrpwm.c
index d560007..9b48d75 100644
--- a/drivers/pwm/ehrpwm.c
+++ b/drivers/pwm/ehrpwm.c
@@ -1246,7 +1246,12 @@ static int ehrpwm_pwm_config(struct pwm_device *p,
 
 	switch (c->config_mask) {
 	case BIT(PWM_CONFIG_PERIOD_TICKS):
-		p->period_ticks = c->period_ticks;
+		if (p->max_period_ticks &&
+				(p->max_period_ticks >= c->period_ticks))
+			p->period_ticks = p->max_period_ticks;
+		else
+			p->period_ticks = c->period_ticks;
+
 		ret = ehrpwm_pwm_set_prd(p);
 		break;
 
@@ -1449,6 +1454,15 @@ set_bit:
 	for (chan = 0; chan < NCHAN; chan++) {
 		ehrpwm->pwm[chan].ops = &ehrpwm->ops;
 		pwm_set_drvdata(&ehrpwm->pwm[chan], ehrpwm);
+		ehrpwm->pwm[chan].tick_hz = clk_get_rate(ehrpwm->clk);
+
+		if (pdata->chan_attrib[chan].max_freq) {
+			int period_ns = NSEC_PER_SEC
+				/ pdata->chan_attrib[chan].max_freq;
+
+			ehrpwm->pwm[chan].max_period_ticks =
+				pwm_ns_to_ticks(&ehrpwm->pwm[chan], period_ns);
+		}
 
 		if (!(ehrpwm->version == PWM_VERSION_1)) {
 			if (!(ch_mask & (0x1 << chan)))
diff --git a/include/linux/pwm/pwm.h b/include/linux/pwm/pwm.h
index 76b57a3..3bab0a1 100644
--- a/include/linux/pwm/pwm.h
+++ b/include/linux/pwm/pwm.h
@@ -102,22 +102,31 @@ struct pwm_device {
 	unsigned long period_ns;
 	unsigned long duty_ns;
 	struct notifier_block freq_transition;
+	unsigned long max_period_ticks;
 	spinlock_t pwm_lock;
 };
 
 #include <linux/semaphore.h>
+#include <linux/pwm/ehrpwm.h>
 
 enum {
 	PWM_VERSION_0,
 	PWM_VERSION_1,
 };
 
+struct pwm_chan_attrib {
+	int max_freq;
+};
+
+#define PWM_CHANNEL NCHAN
+
 struct pwmss_platform_data {
 	int channel_mask;
 	struct semaphore config_semaphore;
 	int pwmss_module_usage_count;
 	void *config_mem_base;
 	u8 version;
+	struct pwm_chan_attrib chan_attrib[PWM_CHANNEL];
 };
 
 struct pwm_device *pwm_request_byname(const char *name, const char *label);
-- 
1.7.11.2

