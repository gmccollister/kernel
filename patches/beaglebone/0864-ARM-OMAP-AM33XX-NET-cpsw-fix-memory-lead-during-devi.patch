From 851e8ce37dd6f3b07f2969b3ee3e7907799a2534 Mon Sep 17 00:00:00 2001
From: Mugunthan V N <mugunthanvnm@ti.com>
Date: Thu, 8 Mar 2012 09:42:02 +0530
Subject: [PATCH 0864/1092] ARM: OMAP: AM33XX: NET: cpsw: fix memory lead
 during device open close.

Rx descriptors are not freed during cpdma close in device close.

cpdma_ctlr_stop should be called after netif_carrier_off. so that
cpsw_rx_handler knows that we are shutting down the network device
and free the Rx descriptor memory

Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index e209fa0..640ceb8 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -311,6 +311,12 @@ void cpsw_rx_handler(void *token, int len, int status)
 	struct cpsw_priv	*priv = netdev_priv(ndev);
 	int			ret = 0;
 
+	if (unlikely(!netif_running(ndev)) ||
+			unlikely(!netif_carrier_ok(ndev))) {
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
 	if (likely(status >= 0)) {
 		skb_put(skb, len);
 		skb->protocol = eth_type_trans(skb, ndev);
@@ -764,10 +770,10 @@ static int cpsw_ndo_stop(struct net_device *ndev)
 	msg(info, ifdown, "shutting down cpsw device\n");
 	cpsw_intr_disable(priv);
 	cpdma_ctlr_int_ctrl(priv->dma, false);
-	cpdma_ctlr_stop(priv->dma);
 	netif_stop_queue(priv->ndev);
 	napi_disable(&priv->napi);
 	netif_carrier_off(priv->ndev);
+	cpdma_ctlr_stop(priv->dma);
 	cpsw_ale_stop(priv->ale);
 	device_remove_file(&ndev->dev, &dev_attr_hw_stats);
 	for_each_slave(priv, cpsw_slave_stop, priv);
-- 
1.7.11.2

